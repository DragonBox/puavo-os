#!/usr/bin/ruby

# Copyright (C) 2016 Opinsys Oy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#
# for documentation see README.md
#

#
# tested speed on Lenovo ThinkCentre Edge (1578D7G)
#   with 100 hardware-quirks.json files, with 1000 pci-id keys on each:
#   took about 0.8 seconds (not to be taken as an exact value, code may
#   have changed)
#
# ways to optimize:
#   - rewrite in C
#   - have only a few json-files to parse
#   - replace calls for dmidecode, lspci, lsusb with something more efficient
#

require 'getoptlong'
require 'json'

require 'puavo/conf'

def apply_parameter_filters(parameters, parameter_filters, lookup_fn)
    parameter_filters.each do |filter|
        validate_parameter_filter(filter)

        if filter['key'] == '*' then
            parameters.update(filter['parameters'])
            next
        end

        parameter_values = lookup_fn.call(filter['key'])
        next if parameter_values.nil?

        parameter_values.each do |value|
            match_result = match_puavopattern(value,
                                              filter['matchmethod'],
                                              filter['pattern'])
            if match_result then
                parameters.update(filter['parameters'])
                break
            end
        end
    end
end

def validate_value(value)
    return true if value.kind_of?(String)
    raise "Value has unsupported type"
end

def validate_parameter_filter(obj)
    unless obj.kind_of?(Hash)
        raise "Parameter filters must be an hash"
    end
    %w(key matchmethod pattern parameters).each do |required_key|
        unless obj.has_key?(required_key)
            raise "Parameter filter is missing required key '#{required_key}'"
        end
    end
    unless obj['key'].kind_of?(String)
        raise "Parameter filter's key is of wrong type"
    end
    unless %w(exact glob regex).include?(obj['matchmethod'])
        raise "Parameter filter's matchmethod has unknown value"
    end
    unless obj['pattern'].kind_of?(String)
        raise "Parameter filter's pattern is of wrong type"
    end
    unless obj['parameters'].kind_of?(Hash)
        raise "Parameter filter's parameters is of wrong type"
    end
    if obj['parameters'].empty?
        raise "Parameter filter's parameters is empty"
    end
    obj['parameters'].each do |key, value|
        unless key.kind_of?(String)
            raise "Parameter key must be a string"
        end
        validate_value(value)
    end
    true
end

def read_json_obj(file, type)
    obj = JSON.parse(IO.read(file))
    unless obj.kind_of?(type)
        raise "Top-level JSON object of #{file} is not #{type}"
    end
    obj
end

$deviceinfo = {}
def get_device_setting(key)
    # returns nil in case there was a failure
    return $deviceinfo[key] if $deviceinfo.has_key?(key)

    case key
        when 'dmidecode-baseboard-asset-tag',
             'dmidecode-baseboard-manufacturer',
             'dmidecode-baseboard-product-name',
             'dmidecode-baseboard-serial-number',
             'dmidecode-baseboard-version',
             'dmidecode-bios-release-date',
             'dmidecode-bios-vendor',
             'dmidecode-bios-version',
             'dmidecode-chassis-asset-tag',
             'dmidecode-chassis-manufacturer',
             'dmidecode-chassis-serial-number',
             'dmidecode-chassis-type',
             'dmidecode-chassis-version',
             'dmidecode-processor-family',
             'dmidecode-processor-frequency',
             'dmidecode-processor-manufacturer',
             'dmidecode-processor-version',
             'dmidecode-system-manufacturer',
             'dmidecode-system-product-name',
             'dmidecode-system-serial-number',
             'dmidecode-system-uuid',
             'dmidecode-system-version'
                cmdarg = key[ "dmidecode-".length .. -1]
                result = %x(dmidecode -s #{ cmdarg })
                status = $?.exitstatus
                if status != 0 then
                    logerr("dmidecode -s #{ cmdarg } returned #{ status }")
                    $deviceinfo[key] = nil
                else
                    $deviceinfo[key] = [ result.strip ]
                end
        when 'pci-id'
            # might return nil, that is okay
            $deviceinfo[key] = take_field('lspci -n', 3)
        when 'usb-id'
            # might return nil, that is okay
            $deviceinfo[key] = take_field('lsusb', 6)
        else
            logerr("Unknown device key #{ key }")
            $deviceinfo[key] = nil
    end

    return $deviceinfo[key]
end

def logwarn(msg)
    warn("Warning: #{msg}")
end

def logerr(msg)
    warn("Error: #{msg}")
    $status = 1
end

def match_puavopattern(target, matchmethod, pattern)
    # XXX if 'logic' matchmethod is going to be implemented
    # XXX pattern might not be a string?
    if !pattern.kind_of?(String) then
        logerr('input type error: match pattern is not a string')
        return
    end

    case matchmethod
        when 'exact'
            return target == pattern
        when 'glob'
            return File.fnmatch(pattern, target)
        when 'logic'
            logerr("Match method logic not implemented yet")
            return false
        when 'regex'
            return target.match(pattern) ? true : false
        else
            logerr("Match method #{ matchmethod } is unsupported")
    end

    return false
end

def take_field(cmd, fieldnum)
    result = %x(#{ cmd })
    status = $?.exitstatus
    if status != 0 then
        logerr("#{ cmd } returned #{ status }")
        return nil
    end

    result.split("\n").map { |line| (line.split(' '))[fieldnum-1] }
end

def usage()
    puts <<-EOF
Usage:
    puavo-conf-update [OPTION]...

Update configuration database by overwriting parameter values from the
following sources, in the given order:

  1. hardware quirks
  2. device specific settings from '#{$devicejson_path}'
  3. kernel command line

Options:
  --help, -h                  display this help and exit

  --devicejson-path FILE      filepath of the device.json, defaults to
                              '#{$devicejson_path}'

EOF
end

def get_hwquirk_params()
    parameters = {}
    files      = Dir.glob('/usr/share/puavo-conf/hwquirk-overwrites/*.json') rescue []

    files.each do |file|
        apply_parameter_filters(parameters,
                                read_json_obj(file, Array),
                                Proc.method(:get_device_setting))
    end

    return parameters
end

def get_devicejson_params()
    begin
        device = read_json_obj($devicejson_path, Hash)
    rescue Errno::ENOENT
        return {}
    end
    device['conf'] or {}
end

def get_kernelarg_params()
    parameters = {}

    IO.read('/proc/cmdline').split.each do |kernel_arg|
        if kernel_arg =~ /\A(puavo\..*)=(.*)\Z/
            parameters[$1] = $2
        end
    end

    return parameters
end

def get_hosttype_params(hosttype)
    return {} if hosttype.nil?

    begin
        read_json_obj("/usr/share/puavo-conf/hosttype-overwrites/#{hosttype}.json", Hash)
    rescue Errno::ENOENT
        {}
    end
end

## Main

$status = 0

$devicejson_path = '/etc/puavo/device.json'

begin
    opts = GetoptLong.new(['--help', '-h',      GetoptLong::NO_ARGUMENT],
                          ['--devicejson-path', GetoptLong::REQUIRED_ARGUMENT])

    opts.each do |opt, arg|
        case opt
            when '--help'
                usage
                exit 0
            when '--devicejson-path'
                $devicejson_path = arg
        end
    end

rescue GetoptLong::InvalidOption => e
    usage
    exit 1
end

params = {}

hwquirk_params    = get_hwquirk_params
devicejson_params = get_devicejson_params
kernelarg_params  = get_kernelarg_params
hosttype_params   = get_hosttype_params(kernelarg_params['puavo.hosttype')

params.update(hosttype_params)
params.update(hwquirk_params)
params.update(devicejson_params)
params.update(kernelarg_params)

puavoconf = Puavo::Conf.new()
begin
    params.each do |key, value|
        begin
            puavoconf.overwrite(key, value)
        rescue StandardError => e
            logerr("Failed to overwrite a parameter: " \
                   "#{key}=#{value}: #{e.message}")
        end
    end
ensure
    puavoconf.close
end

exit($status)
