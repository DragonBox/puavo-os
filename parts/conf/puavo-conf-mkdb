#!/usr/bin/ruby

# Copyright (C) 2016 Opinsys Oy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#
# 1. image defaults
# 2. feature-profiles
# 3. hardware quirks database
# 4. settings from puavo
# 5. primary user preferences (currently unimplemented)
# 6. kernel arguments
#

#
# tested speed on Lenovo ThinkCentre Edge (1578D7G)
#   with 100 hardware-quirks.json files, with 1000 pci-id keys on each:
#   took about 0.8 seconds (not to be taken as an exact value, code may
#   have changed)
#
# ways to optimize:
#   - rewrite in C
#   - have only a few json-files to parse
#   - replace calls for dmidecode, lspci, lsusb with something more efficient
#

require 'json'
require 'puavo/conf'

$status = 0

$deviceinfo = {}
def get_device_setting(key)
    # returns nil in case there was a failure
    return $deviceinfo[key] if $deviceinfo.has_key?(key)

    case key
        when 'dmidecode-baseboard-asset-tag',
             'dmidecode-baseboard-manufacturer',
             'dmidecode-baseboard-product-name',
             'dmidecode-baseboard-serial-number',
             'dmidecode-baseboard-version',
             'dmidecode-bios-release-date',
             'dmidecode-bios-vendor',
             'dmidecode-bios-version',
             'dmidecode-chassis-asset-tag',
             'dmidecode-chassis-manufacturer',
             'dmidecode-chassis-serial-number',
             'dmidecode-chassis-type',
             'dmidecode-chassis-version',
             'dmidecode-processor-family',
             'dmidecode-processor-frequency',
             'dmidecode-processor-manufacturer',
             'dmidecode-processor-version',
             'dmidecode-system-manufacturer',
             'dmidecode-system-product-name',
             'dmidecode-system-serial-number',
             'dmidecode-system-uuid',
             'dmidecode-system-version'
                cmdarg = key[ "dmidecode-".length .. -1]
                result = %x(dmidecode -s #{ cmdarg })
                status = $?.exitstatus 
                if status != 0 then
                    logerr("dmidecode -s #{ cmdarg } returned #{ status }")
                    $deviceinfo[key] = nil
                else
                    $deviceinfo[key] = [ result.strip ]
                end
        when 'pci-id'
            # might return nil, that is okay
            $deviceinfo[key] = take_field('lspci -n', 3)
        when 'usb-id'
            # might return nil, that is okay
            $deviceinfo[key] = take_field('lsusb', 6)
        else
            logerr("Unknown device key #{ key }")
            $deviceinfo[key] = nil
    end

    return $deviceinfo[key]
end

def logerr(msg)
    warn(msg)
    $status = 1
end

def lookup_features_by_key(matchmethod, hwquirkset)
    if !hwquirkset.kind_of?(Hash) then
        logerr('input type error: hwquirkset is not a hash')
        return
    end

    hwquirkset.each do |quirktype, quirkmap|
        if !quirktype.kind_of?(String) then
            logerr('input type error: quirktype is not a string')
            next
        end

        if !quirkmap.kind_of?(Hash) then
            logerr('input type error: quirkmap is not a hash')
            next
        end

        case quirktype
            when ':exact:', ':glob:', ':logic:', ':regex:'
                lookup_features_by_key(quirktype, quirkmap)

            when /\Admidecode-.*\Z/, 'pci-id', 'usb-id'
                # device_setting is a list, because it might be
                # a list of PCIs or USBs
                device_setting = get_device_setting(quirktype)
                quirkmap.each do |pattern, featureconf|
                    if !pattern.kind_of?(String) then
                        logerr('input type error: pattern is not a string')
                        next
                    end
                    if !featureconf.kind_of?(Hash) then
                        logerr('input type error: featureconf is not a hash')
                        next
                    end

                    device_setting.each do |id|
                        if match_hwquirk(id, matchmethod, pattern) then
                            merge_features(featureconf)
                        end
                    end
                end
            else
                logerr("Unknown quirktype: #{ quirktype }")
        end
    end
end

def match_hwquirk(target, matchmethod, pattern)
    case matchmethod
        when ':exact:'
            return target == pattern
        when ':glob:'
            return File.fnmatch(pattern, target)
        when ':logic:'
            logerr(":logic: matcher not implemented yet")
            return false
        when ':regex:'
            return target.match(pattern) ? true : false
        else
            logerr("Match method #{ matchmethod } is unsupported")
    end

    return false
end

def merge_features(featureconf)
    featureconf.each do |key, value|
        if !key.kind_of?(String) then
            logerr('input type error: key not a string')
            next
        end

        if !(value == true || value == false \
               || value.kind_of?(Integer) \
               || value.kind_of?(String)) then
            logerr('input type error: value not valid')
            next
        end

        $features[key] = value
    end
end

def take_field(cmd, fieldnum)
    result = %x(#{ cmd })
    status = $?.exitstatus
    if status != 0 then
        logerr("#{ cmd } returned #{ status }")
        return nil
    end

    result.split("\n").map { |line| (line.split(' '))[fieldnum-1] }
end

if Process.euid != 0 then
    logerr("#{ File.basename($0) } must be run as root")
    exit 1
end

Hardware_quirks_globpattern = '/usr/share/puavo/hwquirks/*/*.json'
Image_defaults_globpattern  = '/usr/share/puavo/features/*/info.json'

$features = {}
$status = 0

puavo_settings = nil
begin
    puavo_settings = JSON.parse( IO.read('/etc/puavo/device.json') )
rescue StandardError => e
    logerr('Could not read features from /etc/puavo/device.json: ' \
              + e.message)
    $status = 1
end

# 1. image defaults

image_defaults_files = Dir.glob(Image_defaults_globpattern) rescue []
if image_defaults_files.count == 0 then
    logerr('No image defaults files found')
end

image_defaults_files.each do |file|
    begin
        feature_info = JSON.parse( IO.read(file) )
        if !feature_info.kind_of?(Hash) then
            raise 'input type error: image defaults is not a Hash'
        end

        if !(feature_info.has_key?('keys') \
               && feature_info['keys'].kind_of?(Hash)) then
                raise 'input type error: keys value not a Hash'
        end

        feature_info['keys'].each do |key, keyinfo|
            if !keyinfo.kind_of?(Hash) then
                logerr('input type error: defaults keyinfo not a hash')
                next
            end
            if !keyinfo.has_key?('default') then
                logerr('input type error: keyinfo does not have' \
                         + ' a default value')
                next
            end

            merge_features({ key => keyinfo['default'] })
        end
    rescue StandardError => e
        logerr("Could not read feature defaults from #{ file }: " \
                 + e.message)
    end
end

# 2. feature-profiles

# XXX

# 3. check settings based on hardware quirks (dmidecode, pci, usb, ...)

hwquirk_files = Dir.glob(Hardware_quirks_globpattern) rescue []
hwquirk_files.each do |hwquirk_file|
    begin
        hwquirklist = JSON.parse( IO.read(hwquirk_file) )
        if !hwquirklist.kind_of?(Array) then
            logerr('input type error: hwquirklist is not an array')
            next
        end

        hwquirklist.each do |hwquirkset|
            lookup_features_by_key(':exact:', hwquirkset)
        end
    rescue StandardError => e
        logerr("could not read hardware quirks from #{ hwquirk_file }: " \
                 + e.message)
    end
end

# 4. check settings from puavo

if !(puavo_settings.kind_of?(Hash) \
       && puavo_settings['features'].kind_of?(Hash)) then
    logerr('input type error: puavo feature settings not in correct format')
else
    merge_features(puavo_settings['features'])
end

# 5. check primary user preferences

# XXX

# 6. check kernel arguments

# XXX should blow up if /proc/cmdline can not be read?
cmdline_path = '/proc/cmdline'
IO.read(cmdline_path).split.each do |kernel_arg|
    match = kernel_arg.match(/\Apuavo\.feature\.(.*?)=(.*)\Z/)
    if match then
        merge_features({ match[1] => match[2] })
    end
end

#
# make db
#

# XXX value could be be of type { '+': [ ... ], '-': [ ... ]},
# XXX ... could be Arrays, we could them serialize
# XXX those into the database with [].join(',').
# XXX this should have been handled previously

puts "Creating puavo-conf database with the following values:\n"
puavoconf = Puavo::Conf.new()
$features.sort.each do |key, value|
    puavoconf.set(key.to_s, value.to_s)
    puts "    #{ key }=#{ value }"
end
puavoconf.close

exit($status)
