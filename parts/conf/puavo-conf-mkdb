#!/usr/bin/ruby

# Copyright (C) 2016 Opinsys Oy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#
# for documentation see README.md
#

#
# tested speed on Lenovo ThinkCentre Edge (1578D7G)
#   with 100 hardware-quirks.json files, with 1000 pci-id keys on each:
#   took about 0.8 seconds (not to be taken as an exact value, code may
#   have changed)
#
# ways to optimize:
#   - rewrite in C
#   - have only a few json-files to parse
#   - replace calls for dmidecode, lspci, lsusb with something more efficient
#

require 'getoptlong'
require 'json'
require 'puavo/conf'

def apply_parameter_filters(parameters, parameter_filters, lookup_fn)
    if !parameter_filters.kind_of?(Array)
        logerr('input type error: parameter filters not in correct format')
        return
    end

    parameter_filters.each do |filter|
        if !(filter.kind_of?(Hash) \
               && filter['key'].kind_of?(String) \
               && filter['parameters'].kind_of?(Hash)) then
            logerr('input type error: parameter filter not in correct format')
            next
        end

        if filter['key'] == '*' then
            merge_parameters(parameters, filter['parameters'])
            next
        end

        if !(filter['matchmethod'].kind_of?(String)) then
            logerr('input type error: parameter filter not in correct format')
            next
        end

        parameter_values = lookup_fn.call(filter['key'])
        next if parameter_values.nil?

        parameter_values.each do |value|
            match_result = match_puavopattern(value,
                                              filter['matchmethod'],
                                              filter['pattern'])
            if match_result then
                merge_parameters(parameters, filter['parameters'])
                break
            end
        end
    end
end

def read_json_array(file)
    obj = JSON.parse(IO.read(file))
    unless obj.kind_of?(Array)
        raise "Top-level JSON object of #{file} is not an array"
    end
    obj
end

$deviceinfo = {}
def get_device_setting(key)
    # returns nil in case there was a failure
    return $deviceinfo[key] if $deviceinfo.has_key?(key)

    case key
        when 'dmidecode-baseboard-asset-tag',
             'dmidecode-baseboard-manufacturer',
             'dmidecode-baseboard-product-name',
             'dmidecode-baseboard-serial-number',
             'dmidecode-baseboard-version',
             'dmidecode-bios-release-date',
             'dmidecode-bios-vendor',
             'dmidecode-bios-version',
             'dmidecode-chassis-asset-tag',
             'dmidecode-chassis-manufacturer',
             'dmidecode-chassis-serial-number',
             'dmidecode-chassis-type',
             'dmidecode-chassis-version',
             'dmidecode-processor-family',
             'dmidecode-processor-frequency',
             'dmidecode-processor-manufacturer',
             'dmidecode-processor-version',
             'dmidecode-system-manufacturer',
             'dmidecode-system-product-name',
             'dmidecode-system-serial-number',
             'dmidecode-system-uuid',
             'dmidecode-system-version'
                cmdarg = key[ "dmidecode-".length .. -1]
                result = %x(dmidecode -s #{ cmdarg })
                status = $?.exitstatus
                if status != 0 then
                    logerr("dmidecode -s #{ cmdarg } returned #{ status }")
                    $deviceinfo[key] = nil
                else
                    $deviceinfo[key] = [ result.strip ]
                end
        when 'pci-id'
            # might return nil, that is okay
            $deviceinfo[key] = take_field('lspci -n', 3)
        when 'usb-id'
            # might return nil, that is okay
            $deviceinfo[key] = take_field('lsusb', 6)
        else
            logerr("Unknown device key #{ key }")
            $deviceinfo[key] = nil
    end

    return $deviceinfo[key]
end

def logwarn(msg)
    warn("Warning: #{msg}")
end

def logerr(msg)
    warn("Error: #{msg}")
    $status = 1
end

def match_puavopattern(target, matchmethod, pattern)
    # XXX if 'logic' matchmethod is going to be implemented
    # XXX pattern might not be a string?
    if !pattern.kind_of?(String) then
        logerr('input type error: match pattern is not a string')
        return
    end

    case matchmethod
        when 'exact'
            return target == pattern
        when 'glob'
            return File.fnmatch(pattern, target)
        when 'logic'
            logerr("Match method logic not implemented yet")
            return false
        when 'regex'
            return target.match(pattern) ? true : false
        else
            logerr("Match method #{ matchmethod } is unsupported")
    end

    return false
end

def merge_parameters(parameters, parameterconf)
    if !parameterconf.kind_of?(Hash) then
        logerr('input type error: parameterconf is not a hash')
        return
    end

    parameterconf.each do |key, value|
        if !key.kind_of?(String) then
            logerr('input type error: key not a string')
            next
        end

        if !(value == true || value == false \
               || value.kind_of?(Integer) \
               || value.kind_of?(String)) then
            logerr('input type error: value not valid')
            next
        end

        parameters[key] = value.to_s
    end
end

def take_field(cmd, fieldnum)
    result = %x(#{ cmd })
    status = $?.exitstatus
    if status != 0 then
        logerr("#{ cmd } returned #{ status }")
        return nil
    end

    result.split("\n").map { |line| (line.split(' '))[fieldnum-1] }
end

def usage()
    puts <<-EOF
Usage:
    puavo-conf-mkdb [--sources comma-separated-list-of-sources]

By default the list of used sources is
"filters hwquirks puavo localconf kernelargs"
and these are the only available configuration sources.
EOF
end

class Sources
    attr_reader :parameters

    Available = %w(filters hwquirks puavo localconf kernelargs)

    def initialize(sources, parameters)
        @sources = []
        sources.each do |source|
            if !Available.include?(source) then
                warn("source '#{ source }' is unknown")
                next
            end

            @sources << source
        end

        @parameters_by_source = {}

        @sources.each do |source|
            next if source == 'filters'
            @parameters_by_source[source] = send(source)
        end

        # Filters are special: other sources affect the filters chosen.
        # Note that in merge() source order always matters.
        filter_sources = merge()
        @parameters_by_source['filters'] = filters(filter_sources)

        @parameters = merge()
    end

    def merge
        parameters = {}
        @sources.each do |source|
            next unless @parameters_by_source.has_key?(source)
            parameters.merge!( @parameters_by_source[source] )
        end

        return parameters
    end

    # parameter-filters
    def filters(parameter_configuration)
        parameters = {}

        parameter_filters = []
        parameter_filters_path = '/etc/puavoimage/parameter-filters.json'
        begin
            parameter_filters = JSON.parse( IO.read(parameter_filters_path) )
            parameter_lookup = lambda do |key|
                                 parameter_configuration.has_key?(key)  \
                                     ? [ parameter_configuration[key] ] \
                                     : nil
                             end
            apply_parameter_filters(parameters, parameter_filters, parameter_lookup)
        rescue StandardError => e
            logerr('Could not apply parameter filters from' \
                     + " #{ parameter_filters_path }: #{ e.message }")
        end

        return parameters
    end

    # settings based on hardware quirks (dmidecode, pci, usb, ...)
    def hwquirks
        parameters = {}

        hardware_quirks_globpattern = '/usr/share/puavo-conf/hwquirks/*.json'

        hwquirk_files = Dir.glob(hardware_quirks_globpattern) rescue []
        hwquirk_files.each do |hwquirk_file|
            begin
                hwquirklist = JSON.parse( IO.read(hwquirk_file) )
                apply_parameter_filters(parameters,
                                       hwquirklist,
                                       Proc.method(:get_device_setting))
            rescue StandardError => e
                logerr('could not read hardware quirks from' \
                         + " #{ hwquirk_file }: #{  e.message }")
            end
        end

        return parameters
    end

    # settings from puavo
    def puavo
        parameters = {}

        begin
            puavo_settings = JSON.parse( IO.read('/etc/puavo/device.json') )
            if !(puavo_settings.kind_of?(Hash) \
                   && puavo_settings['parameters'].kind_of?(Hash)) then
                raise 'input type error: puavo parameter settings' \
                        + ' not in correct format'
            end

            puavo_settings['parameters'].each do |key, value|
                merge_parameters(parameters, { key => value })
            end
        rescue StandardError => e
            logerr('Could not read parameters from /etc/puavo/device.json: ' \
                      + e.message)
        end

        return parameters
    end

    # settings from primary user
    def localconf
        # XXX unimplemented
        return {}
    end

    # settings from kernel arguments
    def kernelargs
        parameters = {}

        begin
            IO.read('/proc/cmdline').split.each do |kernel_arg|
                if kernel_arg =~ /\A(puavo\..*)=(.*)\Z/
                    merge_parameters(parameters, { $1 => $2 })
                end
            end
        rescue StandardError => e
            logerr('Failed to parameters from the kernel command line')
        end

        return parameters
    end
end

def get_parameter_definitions
    result      = {}
    globpattern = '/usr/share/puavo-conf/parameters/*.json'

    files = Dir.glob(globpattern) rescue []
    logwarn('No parameter definitions found') if files.empty?

    files.each do |file|
        begin
            parameter_definitions = JSON.parse(IO.read(file))

            parameter_definitions.each_pair do |key, info|
                unless info.kind_of?(Hash)
                    logerr('Parameter definition must be a hash')
                    next
                end
                unless info.has_key?('default')
                    logerr('Parameter definition must have a default value')
                    next
                end

                merge_parameters(parameters, { key => info['default'] })
            end
        rescue StandardError => e
            logerr("Could not read parameter definitions from #{ file }: " \
                   + e.message)
        end
    end

    return parameters
end

## Main

if Process.euid != 0 then
    logerr("#{ File.basename($0) } must be run as root")
    exit 1
end

$status = 0

conf_sources = %w(filters hwquirks puavo localconf kernelargs)

begin
    opts = GetoptLong.new([ '--sources', GetoptLong::REQUIRED_ARGUMENT ])

    opts.each do |opt, arg|
        case opt
            when '--sources'
                conf_sources = arg.split(',')
        end
    end

rescue GetoptLong::InvalidOption => e
    usage
    exit 1
end

puavoconf = Puavo::Conf.new()

parameters = get_parameter_definitions()

parameters.sort.each do |key, value|
    begin
        puavoconf.add(key, value)
    rescue StandardError => e
        logerr("Failed to add a new parameter: #{key}=#{value}: #{e.message}")
    end
end

sources = Sources.new(conf_sources, parameters)

parameters = sources.parameters
parameters.sort.each do |key, value|
    begin
        puavoconf.overwrite(key, value)
    rescue StandardError => e
        logerr("Failed to overwrite a parameter: #{key}=#{value}: #{e.message}")
    end
end
puavoconf.close

exit($status)
