#!/usr/bin/python3

# New user registration dialog v0.5

# TODO:
#  - everything

import re
import json
import time
import socket
import threading
import subprocess
import unicodedata
import http.client

import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GLib, Pango


# Used when interpreting a failed server response
FIELD_ERRORS = {
    'first_name': {
        'name': 'etunimi',
        'reasons': {
            'empty': 'on tyhjä',
            'failed_validation': 'sisältää virheellisiä merkkejä',
        }
    },

    'last_name': {
        'name': 'sukunimi',
        'reasons': {
            'empty': 'on tyhjä',
            'failed_validation': 'sisältää virheellisiä merkkejä',
        }
    },

    'username': {
        'name': 'käyttäjänimi',
        'reasons': {
            'empty': 'on tyhjä',
            'failed_validation': 'sisältää virheellisiä merkkejä',
        }
    },

    'email': {
        'name': 'email',
        'reasons': {
            'empty': 'on tyhjä',
            'failed_validation': 'sisältää virheellisiä merkkejä',
        }
    },
}

# These language codes must be the same that are configured/allowed on the server!
LANGUAGES = [
    ('fi_FI.UTF-8', 'Suomi'),
    ('sv_FI.UTF-8', 'Ruotsi'),
    ('en_US.UTF-8', 'Englanti'),
    ('de_CH.UTF-8', 'Saksa'),
]

USERNAME_FILTER = re.compile(r'[^a-z|0-9|.|\-|_]')


class UserRegistration:
    def __init__(self, builder):
        self.builder = builder
        self.window = self.builder.get_object('register_window')

        # Get object handles
        self.frame = self.builder.get_object('register_frame')
        self.first_name_field = self.builder.get_object('first_name')
        self.last_name_field  = self.builder.get_object('last_name')
        self.username_field   = self.builder.get_object('username')
        self.username_hint    = self.builder.get_object('username_hint')
        self.email_field      = self.builder.get_object('email')
        self.password_field   = self.builder.get_object('password')
        self.password_confirm_field \
            = self.builder.get_object('password_confirm')
        self.language_combo   = self.builder.get_object('language')
        self.phone_field      = self.builder.get_object('phone_number')
        self.spinner          = self.builder.get_object('spinner')
        self.status           = self.builder.get_object('status_message')

        self.submit_button = self.builder.get_object('submit')
        self.reset_button  = self.builder.get_object('reset')

        self.username_change_signal = -1

        self.network_thread = None
        self.network_thread_event = None

        # Setup initial values
        for lang in LANGUAGES:
            self.language_combo.insert(-1, lang[0], lang[1])

        self.language_combo.set_active(0)

        # Setup event handling
        handlers = {
            'on_first_name_changed': self.on_first_name_changed,
            'on_last_name_changed': self.on_last_name_changed,
            'on_username_changed': self.on_username_changed,
            'on_email_changed': self.on_email_changed,
            'on_password_changed': self.on_password_changed,
            'on_password_confirm_changed': self.on_password_confirm_changed,
            'on_language_changed': self.on_language_changed,
            'on_phone_number_changed': self.on_phone_number_changed,

            'on_submit_clicked': self.on_submit_clicked,
            'on_reset_clicked': self.on_reset_clicked,

            'on_destroy': self.on_destroy,
        }

        self.builder.connect_signals(handlers)

        # Manually bind this event because we need the signal ID and
        # connect_signals() won't return them
        self.username_change_signal \
            = self.username_field.connect('changed', self.on_username_changed)

        self.set_username_hint_status(True)
        self.set_submit_state()
        self.status.set_text('')


    def show_info_message(self, parent, message, secondary_message=None):
        """Show a modal information message box."""

        dialog = Gtk.MessageDialog(parent=parent,
                                   flags=Gtk.DialogFlags.MODAL,
                                   type=Gtk.MessageType.INFO,
                                   buttons=Gtk.ButtonsType.OK,
                                   message_format=message)

        if secondary_message:
            dialog.format_secondary_markup(secondary_message)

        dialog.run()
        dialog.hide()


    def show_error_message(self, parent, message, secondary_message=None):
        """Show a modal error message box."""

        dialog = Gtk.MessageDialog(parent=parent,
                                   flags=Gtk.DialogFlags.MODAL,
                                   type=Gtk.MessageType.ERROR,
                                   buttons=Gtk.ButtonsType.OK,
                                   message_format=message)

        if secondary_message:
            dialog.format_secondary_markup(secondary_message)

        dialog.run()
        dialog.hide()


    def set_username_hint_status(self, is_good=True):
        color = '#888' if is_good else '#f00'
        self.username_hint.set_markup('<span color="%s">Käyttäjätunnuksiin kelpaavat merkit a-z, 0-9, -, _ ja piste.</span>' % color)


    def set_submit_state(self):
        state = True

        if len(self.first_name_field.get_text().strip()) == 0:
            state = False

        if len(self.last_name_field.get_text().strip()) == 0:
            state = False

        if len(self.username_field.get_text().strip()) == 0 or \
          re.search(USERNAME_FILTER, self.username_field.get_text()):
            state = False

        if len(self.email_field.get_text().strip()) == 0:
            state = False

        if len(self.password_field.get_text()) == 0:
            state = False

        if len(self.password_confirm_field.get_text()) == 0:
            state = False

        if self.password_field.get_text() != self.password_confirm_field.get_text():
            state = False

        self.submit_button.set_sensitive(state)


    def enable_inputs(self, state):
        for obj in self.builder.get_objects():
            if obj is self.status:
                continue

            if isinstance(obj, Gtk.Entry) or \
               isinstance(obj, Gtk.Label) or \
               isinstance(obj, Gtk.Button) or \
               isinstance(obj, Gtk.ComboBoxText):
                obj.set_sensitive(state)


    def update_username(self):
        fn = self.first_name_field.get_text().strip()
        ln = self.last_name_field.get_text().strip()

        if len(fn) == 0 and len(ln) == 0:
            username = ''
        elif len(fn) > 0 and len(ln) == 0:
            username = fn
        elif len(fn) == 0 and len(ln) > 0:
            username = ln
        else:
            username = fn + '.' + ln

        username = username.lower()

        # Decompose Unicode into separate combining characters
        username = unicodedata.normalize('NFD', username)

        # Then remove all bytes outside of the a-z/number/some punctuation range.
        # All accents, diacritics, etc. will disappear, leaving only unaccented
        # characters behind.
        username = re.sub(USERNAME_FILTER, r'', username)

        # Update the username without triggering a "changed" event
        with self.username_field.handler_block(self.username_change_signal):
            self.username_field.set_text(username)


    def on_first_name_changed(self, edit):
        self.update_username()
        self.set_submit_state()


    def on_last_name_changed(self, edit):
        self.update_username()
        self.set_submit_state()


    def on_username_changed(self, edit):
        username = edit.get_text()

        if re.search(USERNAME_FILTER, username):
            self.set_username_hint_status(False)
        else:
            self.set_username_hint_status(True)

        self.set_submit_state()


    def on_email_changed(self, edit):
        self.set_submit_state()


    def on_password_changed(self, edit):
        self.set_submit_state()


    def on_password_confirm_changed(self, edit):
        self.set_submit_state()


    def on_language_changed(self, combo):
        self.set_submit_state()


    def on_phone_number_changed(self, edit):
        self.set_submit_state()


    def handle_server_error(self, response):
        self.show_error_message(self.window, 'Virhe',
           'Palvelinpäässä meni jokin pieleen. Ole hyvä ja ota yhteys tukeen. '
           'Anna tuelle tämä koodi:\n\n<big>{0}</big>'.format(response['log_id']))


    def handle_server_400(self, response):
        if response['status'] == 'missing_data':
            if len(response['failed_fields']) > 0:
                msg = 'Näiden kenttien sisältö ei ole kunnollinen. Tarkista niiden sisältö.\n\n'

                for field in response['failed_fields']:
                    error = FIELD_ERRORS[field['name']]
                    msg += '- {0} {1}\n'.format(error['name'], error['reasons'][field['reason']])

                self.show_error_message(self.window,'Virheellinen data', msg)

        elif response['status'] == 'invalid_username':
            self.show_error_message(self.window, 'Virheellinen data',
                               'Käyttäjätunnus sisältää virheellisiä merkkejä.')

        elif response['status'] == 'invalid_email':
            self.show_error_message(self.window, 'Virheellinen data',
                               'Sähköpostiosoite ei ole kunnollinen.')

        elif response['status'] == 'password_mismatch':
            self.show_error_message(self.window, 'Virheellinen data',
                               'Salasana ja sen varmistus eivät täsmää.')

        elif response['status'] == 'invalid_language':
            self.show_error_message(self.window, 'Virheellinen data',
                               'Kieli on virheellinen.')

        else:
            self.show_error_message(self.window, 'Virhe',
               'Käyttäjätietojen käsittelyssä tapahtui tuntematon virhe. '
               'Ota yhteys tukeen ja anne heille tämä koodi:\n\n'
               '<big>{0}</big>'.format(response['log_id']))


    def handle_server_401(self, response):
        if response['status'] == 'unknown_machine':
            # This machine does not exist in the database
            self.show_error_message(self.window, 'Rekisteröimätön kone',
                'Koneesi tietoja ei löydy tietokannasta. Ole hyvä ja ota '
                'yhteys tukeen. Anna tuelle tämä koodi:\n\n<big>{0}</big>'.
                format(response['log_id']))

        elif response['status'] == 'device_already_in_use':
            # This machine already has a user. THIS SHOULD NOT HAPPEN.
            self.show_error_message(self.window, 'Kone on jo käytössä',
                'Tältä koneelta on jo suoritettu käyttäjän luonti. Ole hyvä ja ota '
                'yhteys tukeen. Anna tuelle tämä koodi:\n\n<big>{0}</big>'.
                format(response['log_id']))

        elif response['status'] == 'server_error':
            self.handle_server_error(response)

        else:
            self.show_error_message(self.window, 'Virhe',
               'Laitetietojen käsittelyssä tapahtui tuntematon virhe. '
               'Ota yhteys tukeen ja anne heille tämä koodi:\n\n'
               '<big>{0}</big>'.format(response['log_id']))


    def handle_server_409(response):
        if response['status'] == 'username_unavailable':
            self.show_error_message(self.window, 'Käyttäjätunnus on jo käytössä',
                'Valitsemasi käyttäjätunnus on jo käytössä. Valitse toinen nimi.')

        elif response['status'] == 'duplicate_email':
            self.show_error_message(self.window, 'Sähköpostiosoite on jo käytössä',
                'Tämä sähköpostiosoite on jo käytössä. Käytä toista osoitetta.\n\n'
                'Jos toisen osoitteen käyttö ei ole mahdollista, ota yhteys tukeen. '
                'Anna heille tämä koodi:\n\n'
                '<big>{0}</big>'.format(response['log_id']))

        else:
            self.show_error_message(self.window, 'Virhe',
               'Käyttäjätietojen käsittelyssä tapahtui tuntematon virhe. '
               'Ota yhteys tukeen ja anne heille tämä koodi:\n\n<big>{0}</big>'.
               format(response['log_id']))


    def handle_server_500(self, response):
        self.handle_server_error(response)


    def handle_network_error(self, msg):
        self.show_error_message(self.window, 'Virhe',
            'Palvelimeen ei saada yhteyttä:\n\n\t{0}\n\n'
            'Tarkista verkkoyhteyden tila ja yritä uudelleen. Jos ongelma toistuu,'
            'ota yhteys tukeen.'.format(msg))


    def idle_func(self, event, thread):
        if event.is_set():
            print('Thread event set, idle function is exiting')
            self.status.set_text('')
            self.spinner.stop()

            if thread.response['failed']:
                if thread.response['error'] == 'timeout':
                    self.show_error_message(self.window, 'Virhe',
                        'Palvelin ei vastaa pyyntöön. Yritä lähetystä uudelleen hetken kuluttua. '
                        'Jos tilanne toistuu, ota yhteys tukeen.')
                else:
                    self.handle_network_error(thread.response['error'])
            else:
                self.interpret_server_response(
                    thread.response['code'],
                    thread.response['headers'],
                    thread.response['data'])

            self.enable_inputs(True)

            # Remove the idle function
            return False

        # Don't make CPU fans spin. This idle function is called where there
        # are no other messages to handle and that includes the server response
        # waiting. It's a long time to listen to CPU fans whirring...
        time.sleep(0.05)

        # Don't remove the idle function yet
        return True


    def interpret_server_response(self, response_code, response_headers,
      response_data):
        # Parse the returned JSON
        try:
            print('Trying to parse server response |{0}|'.format(response_data))
            server_data = response_data.decode('utf-8')
            server_json = json.loads(server_data)
        except Exception as e:
            self.show_error_message(self.window, 'Virhe',
                'Palvelimen lähettämää vastausta ei pystytty tulkitsemaan.\n\n'
                'Ole hyvä ja ota yhteys tukeen.')
            self.enable_inputs(True)
            return

        try:
            if response_code == 400:            # missing/incomplete/invalid data
                self.handle_server_400(server_json)
                self.enable_inputs(True)
                return
            elif response_code == 401:          # device errors
                self.handle_server_401(server_json)
                self.enable_inputs(True)
                return
            elif response_code == 409:          # unavailable username/email
                self.handle_server_409(server_json)
                self.enable_inputs(True)
                return
            elif response_code == 500:          # server errors
                self.handle_server_500(server_json)
                self.enable_inputs(True)
                return
            elif response_code == 200:          # the good response
                self.show_info_message(self.window,
                    'Tunnus luotu',
                    'Tunnuksesi on luotu. Voit aloittaa koneen käytön.\n\nMukavia hetkiä opiskelun pariin!')
                self.enable_inputs(True)

                # Quit
                Gtk.main_quit()

                return

            # All other return codes fall through to the "should not get here"
            # block below

        except Exception as e:
            self.show_error_message(self.window,
                'Jokin meni pieleen',
                'Palvelimen palauttamaa viestiä ei pystytty tulkitsemaan. Ole hyvä ja ota yhteys tukeen.')
            return

        # If we get here, something has gone horribly wrong
        self.show_error_message(self.window,
            'Jokin meni pieleen',
            'Tätä viestiä ei pitäisi tulla. Koska luet sitä nyt, on jokin mennyt pahasti pieleen.'
            'Ole hyvä ja ota yhteys tukeen.')


    def on_submit_clicked(self, button):
        # --------------------------------------------------------------------------
        # Gather data

        user = {}
        user['first_name'] = self.first_name_field.get_text().strip()
        user['last_name'] = self.last_name_field.get_text().strip()
        user['username'] = self.username_field.get_text()
        user['email'] = self.email_field.get_text().strip()
        user['password'] = self.password_field.get_text()
        user['password_confirm'] = self.password_confirm_field.get_text()
        user['language'] = LANGUAGES[self.language_combo.get_active()][0]
        user['phone'] = self.phone_field.get_text().strip()

        machine = {}

        try:
            machine['dn'] = open('data/dn', 'rb').read().decode('utf-8').strip()
            machine['password'] = open('data/password', 'rb').read().decode('utf-8').strip()
            machine['hostname'] = open('data/hostname', 'rb').read().decode('utf-8').strip()
        except Exception as e:
            print(e)

        data = {}
        data['user'] = user
        data['machine'] = machine

        json_data = json.dumps(data, ensure_ascii=False)

        # --------------------------------------------------------------------------
        # Launch a background thread

        self.status.set_text('Lähetetään tiedot palvelimelle...')
        self.enable_inputs(False)
        self.spinner.start()

        self.network_thread_event = threading.Event()

        self.network_thread = NetworkThread(json_data,
                                            self.network_thread_event)
        self.network_thread.daemon = True
        self.network_thread.start()

        # This will interpret the server's response
        GLib.idle_add(self.idle_func, self.network_thread_event,
            self.network_thread)


    def on_reset_clicked(self, button):
        self.first_name_field.set_text('')
        self.last_name_field.set_text('')

        with self.username_field.handler_block(self.username_change_signal):
            self.username_field.set_text('')

        self.email_field.set_text('')
        self.password_field.set_text('')
        self.password_confirm_field.set_text('')
        self.language_combo.set_active(0)        # triggers a "change" event, but it's okay
        self.phone_field.set_text('')

        self.submit_button.set_sensitive(False)

        self.first_name_field.grab_focus()


    def on_destroy(self, *args):
        Gtk.main_quit()


class WifiConnector:
    def __init__(self):
        self.window = Gtk.Window()
        self.window.set_default_geometry(800, 220)

        self.network_choice_widget = Gtk.ListBox()
        self.network_choice_widget.connect('row-activated',
                                           self.wifi_connection_chosen)

        box = Gtk.Box()
        scrolled_win = Gtk.ScrolledWindow()
        scrolled_win.add(self.network_choice_widget)
        self.password_entry = Gtk.Entry()
        self.password_entry.set_visibility(False)
        connect_button = Gtk.Button(label='connect')
        connect_button.connect('clicked', self.connect_to_wifi)

        box.pack_start(scrolled_win, True, True, 0)
        box.pack_start(self.password_entry, True, True, 0)
        box.pack_start(connect_button, True, True, 0)

        self.network_ssid = None

        self.window.connect('destroy', Gtk.main_quit)
        self.window.add(box)
        self.window.show_all()


    def connect_to_wifi(self, widget):
        if not self.network_ssid:
            return
        wifi_password = self.password_entry.get_buffer().get_text()
        cmd = [ 'nmcli', 'device', 'wifi', 'connect', self.network_ssid,
                'password', wifi_password ]
        subprocess.check_call(cmd)


    def wifi_connection_chosen(self, listbox, row):
        self.network_ssid = self.networks_by_widgets[row]


    def prepare_ui(self):
        self.networks = self.get_networks_info()
        self.networks_by_widgets = {}

        sorted_by_signal = sorted(self.networks,
                                  key=lambda x: self.networks.get(x)['signal'],
                                  reverse=True)
        for ssid in sorted_by_signal:
            row = Gtk.ListBoxRow()
            label = Gtk.Label(label=ssid)
            row.add(label)
            self.network_choice_widget.add(row)
            self.networks_by_widgets[row] = ssid

        self.window.show_all()


    def get_networks_info(self):
        cmd = [ 'nmcli', '-t', '-f', 'SSID,SIGNAL,SECURITY', 'dev', 'wifi' ]
        output = subprocess.check_output(cmd).rstrip().decode('utf-8')
        networks = {}
        for network_line in output.split("\n"):
            network_line_fields = network_line.split(':')
            if len(network_line_fields) != 3:
                continue

            (ssid, signal, security) = network_line_fields

            if not ssid in networks:
                networks[ssid] = { 'signal': 0, 'security': None }

            try:
                max_signal = max(int(signal), networks[ssid]['signal'])
                networks[ssid]['signal'] = max_signal
            except ValueError:
                pass

        return networks



class NetworkThread(threading.Thread):
    def __init__(self, json, event):
        super().__init__()
        self.json = json
        self.event = event
        self.response = {}


    def run(self):
        self.response['failed'] = False
        self.response['error'] = None

        response = None

        # XXX ip address should change to something stable/configurable
        conn = http.client.HTTPConnection('10.246.133.169', 9491, timeout=10)

        headers = {
            'Content-type': 'application/json',
        }

        try:
            conn.request('POST',
                         '/register_user',
                         body=bytes(self.json, 'utf-8'),
                         headers=headers)

            # Must read the response here, because the "finally" handler
            # closes the connection and that happens before we can read
            # the response
            response = conn.getresponse()
            self.response['code'] = response.status
            self.response['headers'] = response.getheaders()
            self.response['data'] = response.read()

        except socket.timeout as st:
            self.response['error'] = 'timeout'
            self.response['failed'] = True
        except http.client.HTTPException as e:
            self.response['error'] = e
            self.response['failed'] = True
        except Exception as e:
            self.response['error'] = e
            self.response['failed'] = True
        finally:
            conn.close()

        self.event.set()
        print('Network thread exiting')


builder = Gtk.Builder()
builder.add_from_file('./puavo-user-registration.glade')        # XXX path

registration_window = UserRegistration(builder)
app_window = registration_window.window
app_window.show_all()

# wifi_connector = WifiConnector()
# wifi_connector.prepare_ui()

Gtk.main()
