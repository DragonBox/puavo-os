#!/usr/bin/python3

# New user registration dialog

import fcntl
import gettext
import gi
import http.client
import json
import os
import re
import socket
import subprocess
import threading
import time
import unicodedata
import sys

gi.require_version('Gtk', '3.0')
from gi.repository import GLib, Gtk, GObject

gettext.bindtextdomain('puavo-user-registration', '/usr/share/locale')
gettext.textdomain('puavo-user-registration')
_tr = gettext.gettext

# Used when interpreting a failed server response
FIELD_ERRORS = {
    'first_name': {
        'name': _tr('etunimi'),
        'reasons': {
            'empty': _tr('on tyhjä'),
            'failed_validation': _tr('sisältää virheellisiä merkkejä'),
        }
    },

    'last_name': {
        'name': _tr('sukunimi'),
        'reasons': {
            'empty': _tr('on tyhjä'),
            'failed_validation': _tr('sisältää virheellisiä merkkejä'),
        }
    },

    'username': {
        'name': _tr('käyttäjänimi'),
        'reasons': {
            'empty': _tr('on tyhjä'),
            'failed_validation': _tr('sisältää virheellisiä merkkejä'),
        }
    },

    'email': {
        'name': _tr('email'),
        'reasons': {
            'empty': _tr('on tyhjä'),
            'failed_validation': _tr('sisältää virheellisiä merkkejä'),
        }
    },

    'phone': {
        'name': _tr('puhelinnumero'),
        'reasons': {
            'empty': _tr('on tyhjä'),
            'failed_validation': _tr('sisältää virheellisiä merkkejä'),
            'too_long': _tr('on liian pitkä'),
        }
    },
}

# These language codes must be the same that are configured/allowed
# on the server!
LANGUAGES = [
    ('fi_FI.UTF-8', _tr('Suomi')),
    ('sv_FI.UTF-8', _tr('Ruotsi')),
    ('en_US.UTF-8', _tr('Englanti')),
    ('de_CH.UTF-8', _tr('Saksa')),
]

USERNAME_FILTER = re.compile(r'[^a-z|0-9|.|\-|_]')


def go_to_desktop(app_window, widget):
    dialog = Gtk.MessageDialog(app_window, 0, Gtk.MessageType.WARNING,
       Gtk.ButtonsType.OK_CANCEL, _tr('Go to desktop?'))
    dialog.format_secondary_text( _tr('Are you sure you do not want to create a user account?  Without user account, your files will be lost after your desktop session ends.')
    response = dialog.run()
    if response == Gtk.ResponseType.OK:
        Gtk.main_quit()
        sys.exit(0)
    dialog.destroy()


def set_puavoconf_switch():
    cmd = [ 'sudo', '-n',
            '/usr/sbin/puavo-conf-local',
            'puavo.xsessions.user_registration.enabled',
            'false' ]
    subprocess.check_call(cmd)


def usage():
    print("usage: puavo-user-registration [--at-session-startup]",
          file=sys.stderr)
    sys.exit(1)


class UserRegistration:
    def __init__(self, builder, app_window, register_frame, at_session_startup):
        self.builder = builder
        self.app_window = app_window
        self.register_frame = register_frame
        self.at_session_startup = at_session_startup

        # Get object handles
        self.register_user_box = self.builder.get_object('register_user')
        self.first_name_field  = self.builder.get_object('first_name')
        self.last_name_field   = self.builder.get_object('last_name')
        self.username_field    = self.builder.get_object('username')
        self.username_hint     = self.builder.get_object('username_hint')
        self.email_field       = self.builder.get_object('email')
        self.password_field    = self.builder.get_object('password')
        self.password_confirm_field \
            = self.builder.get_object('password_confirm')
        self.language_combo    = self.builder.get_object('language')
        self.phone_field       = self.builder.get_object('phone_number')
        self.spinner           = self.builder.get_object('registration_spinner')
        self.status            = self.builder.get_object('status_message')

        self.submit_button = self.builder.get_object('submit')
        self.reset_button  = self.builder.get_object('reset')

        self.username_change_signal = -1

        self.network_thread = None
        self.network_thread_event = None

        # Setup initial values
        for lang in LANGUAGES:
            self.language_combo.insert(-1, lang[0], lang[1])

        self.language_combo.set_active(0)

        # Setup event handling
        handlers = {
            'on_first_name_changed': self.on_first_name_changed,
            'on_last_name_changed': self.on_last_name_changed,
            'on_username_changed': self.on_username_changed,
            'on_email_changed': self.on_email_changed,
            'on_password_changed': self.on_password_changed,
            'on_password_confirm_changed': self.on_password_confirm_changed,
            'on_language_changed': self.on_language_changed,
            'on_phone_number_changed': self.on_phone_number_changed,

            'on_submit_clicked': self.on_submit_clicked,
            'on_reset_clicked': self.on_reset_clicked,

            'on_destroy': self.on_destroy,
        }

        self.builder.connect_signals(handlers)

        # Manually bind this event because we need the signal ID and
        # connect_signals() won't return them
        self.username_change_signal \
            = self.username_field.connect('changed', self.on_username_changed)

        self.set_username_hint_status(True)
        self.set_submit_state()
        self.status.set_text('')


    def activate(self):
        for child in self.register_frame.get_children():
            self.register_frame.remove(child)
        self.register_frame.add(self.register_user_box)


    def show_info_message(self, parent, message, secondary_message=None):
        """Show a modal information message box."""

        dialog = Gtk.MessageDialog(parent=parent,
                                   flags=Gtk.DialogFlags.MODAL,
                                   type=Gtk.MessageType.INFO,
                                   buttons=Gtk.ButtonsType.OK,
                                   message_format=message)

        if secondary_message:
            dialog.format_secondary_markup(secondary_message)

        dialog.run()
        dialog.hide()


    def show_error_message(self, parent, message, secondary_message=None):
        """Show a modal error message box."""

        dialog = Gtk.MessageDialog(parent=parent,
                                   flags=Gtk.DialogFlags.MODAL,
                                   type=Gtk.MessageType.ERROR,
                                   buttons=Gtk.ButtonsType.OK,
                                   message_format=message)

        if secondary_message:
            dialog.format_secondary_markup(secondary_message)

        dialog.run()
        dialog.hide()


    def set_username_hint_status(self, is_good=True):
        color = '#888' if is_good else '#f00'
        msg = _tr('Käyttäjätunnuksiin kelpaavat merkit a-z, 0-9, -, _ ja piste.')
        self.username_hint.set_markup(
          '<span color="%s">%s</span>' % (color, msg))


    def set_submit_state(self):
        state = True

        if len(self.first_name_field.get_text().strip()) == 0:
            state = False

        if len(self.last_name_field.get_text().strip()) == 0:
            state = False

        if len(self.username_field.get_text().strip()) == 0 or \
          re.search(USERNAME_FILTER, self.username_field.get_text()):
            state = False

        if len(self.email_field.get_text().strip()) == 0:
            state = False

        if len(self.password_field.get_text()) == 0:
            state = False

        if len(self.password_confirm_field.get_text()) == 0:
            state = False

        if self.password_field.get_text() != self.password_confirm_field.get_text():
            state = False

        self.submit_button.set_sensitive(state)


    def enable_inputs(self, state):
        for obj in self.builder.get_objects():
            if obj is self.status:
                continue

            if isinstance(obj, Gtk.Entry) or \
               isinstance(obj, Gtk.Label) or \
               isinstance(obj, Gtk.Button) or \
               isinstance(obj, Gtk.ComboBoxText):
                obj.set_sensitive(state)


    def update_username(self):
        fn = self.first_name_field.get_text().strip()
        ln = self.last_name_field.get_text().strip()

        if len(fn) == 0 and len(ln) == 0:
            username = ''
        elif len(fn) > 0 and len(ln) == 0:
            username = fn
        elif len(fn) == 0 and len(ln) > 0:
            username = ln
        else:
            username = fn + '.' + ln

        username = username.lower()

        # Decompose Unicode into separate combining characters
        username = unicodedata.normalize('NFD', username)

        # Then remove all bytes outside of the a-z/number/some punctuation range.
        # All accents, diacritics, etc. will disappear, leaving only unaccented
        # characters behind.
        username = re.sub(USERNAME_FILTER, r'', username)

        # Update the username without triggering a "changed" event
        with self.username_field.handler_block(self.username_change_signal):
            self.username_field.set_text(username)


    def on_first_name_changed(self, edit):
        self.update_username()
        self.set_submit_state()


    def on_last_name_changed(self, edit):
        self.update_username()
        self.set_submit_state()


    def on_username_changed(self, edit):
        username = edit.get_text()

        if re.search(USERNAME_FILTER, username):
            self.set_username_hint_status(False)
        else:
            self.set_username_hint_status(True)

        self.set_submit_state()


    def on_email_changed(self, edit):
        self.set_submit_state()


    def on_password_changed(self, edit):
        self.set_submit_state()


    def on_password_confirm_changed(self, edit):
        self.set_submit_state()


    def on_language_changed(self, combo):
        self.set_submit_state()


    def on_phone_number_changed(self, edit):
        self.set_submit_state()


    def handle_server_error(self, response):
        self.show_error_message(self.app_window, _tr('Virhe'),
           _tr('Palvelinpäässä meni jokin pieleen.  Ole hyvä ja ota yhteys' \
               ' tukeen.  Anna tuelle tämä koodi:') \
                 + '\n\n<big>{0}</big>'.format(response['log_id']))


    def handle_server_400(self, response):
        if response['status'] == 'missing_data':
            if len(response['failed_fields']) > 0:
                msg = _tr('Näiden kenttien sisällössä on jotain vikaa.' \
                        ' Tarkista niiden sisältö ja yritä uudelleen.\n\n')

                for field in response['failed_fields']:
                    error = FIELD_ERRORS[field['name']]
                    msg += '- {0} {1}\n'.format(error['name'], error['reasons'][field['reason']])

                self.show_error_message(self.app_window,
                                        _tr('Virheelliset tiedot'),
                                        msg)

        elif response['status'] == 'malformed_json':
            # *we* sent invalid data :-(
            self.show_error_message(self.app_window, _tr('Virheelliset tiedot'),
              _tr('Rekisteröintiohjelma lähetti palvelimelle virheellisiä' \
                  ' tietoja. Ole hyvä ja ota yhteys tukeen. Anna tuelle tämä' \
                  ' koodi:' + '\n\n<big>{0}</big>'.format(response['log_id'])))

        elif response['status'] == 'incomplete_data':
            # *we* sent incomplete/missing data :-(
            self.show_error_message(self.app_window,
              _tr('Puutteelliset tiedot'),
              _tr('Rekisteröintiohjelma lähetti palvelimelle puutteellisia' \
              ' tietoja.  Ole hyvä ja ota yhteys tukeen.  Anna tuelle tämä' \
              ' koodi:') + '\n\n<big>{0}</big>'.format(response['log_id']))

        elif response['status'] == 'invalid_username':
            self.show_error_message(self.app_window, _tr('Virheellinen data'),
              _tr('Käyttäjätunnus sisältää virheellisiä merkkejä.'))

        elif response['status'] == 'invalid_email':
            self.show_error_message(self.app_window, _tr('Virheellinen data'),
              _tr('Sähköpostiosoite ei ole kunnollinen.'))

        elif response['status'] == 'password_mismatch':
            self.show_error_message(self.app_window, _tr('Virheellinen data'),
              _tr('Salasana ja sen varmistus eivät täsmää.'))

        elif response['status'] == 'invalid_language':
            self.show_error_message(self.app_window, _tr('Virheellinen data'),
              _tr('Kieli on virheellinen.'))

        else:
            self.show_error_message(self.app_window, _tr('Virhe'),
               _tr('Käyttäjätietojen käsittelyssä tapahtui tuntematon virhe.' \
               ' Ota yhteys tukeen ja anne heille tämä koodi:') \
               '\n\n<big>{0}</big>'.format(response['log_id']))


    def handle_server_401(self, response):
        if response['status'] == 'unknown_machine':
            # This machine does not exist in the database
            self.show_error_message(self.app_window,
                _tr('Rekisteröimätön kone'),
                _tr('Koneesi tietoja ei löydy tietokannasta. Ole hyvä ja ota' \
                    ' yhteys tukeen. Anna tuelle tämä koodi:') \
                + '\n\n<big>{0}</big>'.format(response['log_id']))

        elif response['status'] == 'device_already_in_use':
            # This machine already has a user. THIS SHOULD NOT HAPPEN.
            self.show_error_message(self.app_window, _tr('Kone on jo käytössä'),
                _tr('Tältä koneelta on jo suoritettu käyttäjän luonti.' \
                    ' Ole hyvä ja ota yhteys tukeen. Anna tuelle tämä koodi:') \
                + '\n\n<big>{0}</big>'.format(response['log_id']))

        elif response['status'] == 'server_error':
            self.handle_server_error(response)

        else:
            self.show_error_message(self.app_window, _tr('Virhe'),
               _tr('Laitetietojen käsittelyssä tapahtui tuntematon virhe.' \
               ' Ota yhteys tukeen ja anne heille tämä koodi:') \
               + '\n\n<big>{0}</big>'.format(response['log_id']))


    def handle_server_409(response):
        if response['status'] == 'username_unavailable':
            self.show_error_message(self.app_window,
                _tr('Käyttäjätunnus on jo käytössä'),
                _tr('Valitsemasi käyttäjätunnus on jo käytössä.  Valitse' \
                      + ' toinen nimi.'))

        elif response['status'] == 'duplicate_email':
            self.show_error_message(self.app_window,
                _tr('Sähköpostiosoite on jo käytössä'),
                _tr('Tämä sähköpostiosoite on jo käytössä.  Käytä toista' \
                    'osoitetta.') \
                + '\n\n' \
                + _tr('Jos toisen osoitteen käyttö ei ole mahdollista,' \
                     + ' ota yhteys tukeen.  Anna heille tämä koodi:') \
                + '\n\n<big>{0}</big>'.format(response['log_id']))

        else:
            self.show_error_message(self.app_window, _tr('Virhe'),
               _tr('Käyttäjätietojen käsittelyssä tapahtui tuntematon virhe.' \
                   'Ota yhteys tukeen ja anne heille tämä koodi:') \
               + '\n\n<big>{0}</big>'.format(response['log_id']))


    def handle_server_500(self, response):
        self.handle_server_error(response)


    def handle_network_error(self, msg):
        self.show_error_message(self.app_window, _tr('Virhe'),
            _tr('Palvelimeen ei saada yhteyttä:') \
            + '\n\n\t{0}\n\n'.format(msg) \
            + _tr('Tarkista verkkoyhteyden tila ja yritä uudelleen.') \
            + _tr(' Jos ongelma toistuu, ota yhteys tukeen.'))


    def idle_func(self, event, thread):
        if event.is_set():
            print('Thread event set, idle function is exiting')
            self.status.set_text('')
            self.spinner.stop()

            if thread.response['failed']:
                if thread.response['error'] == 'timeout':
                    self.show_error_message(self.app_window, _tr('Virhe'),
                        _tr('Palvelin ei vastaa pyyntöön.' \
                            ' Yritä lähetystä uudelleen hetken kuluttua.' \
                            ' Jos tilanne toistuu, ota yhteys tukeen.'))
                else:
                    self.handle_network_error(thread.response['error'])
            else:
                self.interpret_server_response(
                    thread.response['code'],
                    thread.response['headers'],
                    thread.response['data'])

            self.enable_inputs(True)

            # Remove the idle function
            return False

        # Don't make CPU fans spin. This idle function is called where there
        # are no other messages to handle and that includes the server response
        # waiting. It's a long time to listen to CPU fans whirring...
        time.sleep(0.05)

        # Don't remove the idle function yet
        return True


    def interpret_server_response(self, response_code, response_headers,
      response_data):
        # Parse the returned JSON
        try:
            print('Trying to parse server response |{0}|'.format(response_data))
            server_data = response_data.decode('utf-8')
            server_json = json.loads(server_data)
        except Exception as e:
            self.show_error_message(self.app_window, _tr('Virhe'),
              _tr('Palvelimen lähettämää vastausta ei pystytty tulkitsemaan.') \
              + '\n\n'
              _tr('Ole hyvä ja ota yhteys tukeen.'))
            self.enable_inputs(True)
            return

        try:
            if response_code == 400:            # missing/incomplete/invalid data
                self.handle_server_400(server_json)
                self.enable_inputs(True)
                return
            elif response_code == 401:          # device errors
                self.handle_server_401(server_json)
                self.enable_inputs(True)
                return
            elif response_code == 409:          # unavailable username/email
                self.handle_server_409(server_json)
                self.enable_inputs(True)
                return
            elif response_code == 500:          # server errors
                self.handle_server_500(server_json)
                self.enable_inputs(True)
                return
            elif response_code == 200:          # the good response
                self.show_info_message(self.app_window,
                    _tr('Tunnus luotu'),
                    _tr('Tunnuksesi on luotu. Voit aloittaa koneen käytön.') \
                      + '\n\n' \
                      + 'Mukavia hetkiä opiskelun pariin!')

                set_puavoconf_switch()
                if self.at_session_startup:
                    subprocess.run([ 'systemctl', 'reboot', '-i'])
                # Quit
                Gtk.main_quit()

                return

            # All other return codes fall through to the "should not get here"
            # block below

        except Exception as e:
            self.show_error_message(self.app_window,
                _tr('Jokin meni pieleen'),
                _tr('Palvelimen palauttamaa viestiä ei pystytty tulkitsemaan. Ole hyvä ja ota yhteys tukeen.'))
            return

        # If we get here, something has gone horribly wrong
        self.show_error_message(self.app_window,
            _tr('Jokin meni pieleen'),
            _tr('Tätä viestiä ei pitäisi tulla.  Koska luet sitä nyt, on jokin mennyt pahasti pieleen.') \
            + _tr('Ole hyvä ja ota yhteys tukeen.'))


    def on_submit_clicked(self, button):
        # --------------------------------------------------------------------------
        # Gather data

        user = {}
        user['first_name'] = self.first_name_field.get_text().strip()
        user['last_name'] = self.last_name_field.get_text().strip()
        user['username'] = self.username_field.get_text()
        user['email'] = self.email_field.get_text().strip()
        user['password'] = self.password_field.get_text()
        user['password_confirm'] = self.password_confirm_field.get_text()
        user['language'] = LANGUAGES[self.language_combo.get_active()][0]
        user['phone'] = self.phone_field.get_text().strip()

        get_password_cmd = [ 'sudo', '-n', 'cat', '/etc/puavo/ldap/password' ]
        machine = {
          'dn':       open('/etc/puavo/ldap/dn', 'rb').read() \
                        .decode('utf-8').rstrip(),
          'hostname': socket.gethostname(),
          'password': subprocess.check_output(get_password_cmd) \
                        .decode('utf-8').rstrip(),
        }

        data = {}
        data['user'] = user
        data['machine'] = machine

        json_data = json.dumps(data, ensure_ascii=False)

        # --------------------------------------------------------------------------
        # Launch a background thread

        self.status.set_text(_tr('Lähetetään tiedot palvelimelle...'))
        self.enable_inputs(False)
        self.spinner.start()

        self.network_thread_event = threading.Event()

        self.network_thread = NetworkThread(json_data,
                                            self.network_thread_event)
        self.network_thread.daemon = True
        self.network_thread.start()

        # This will interpret the server's response
        GLib.idle_add(self.idle_func, self.network_thread_event,
            self.network_thread)


    def on_reset_clicked(self, button):
        self.first_name_field.set_text('')
        self.last_name_field.set_text('')

        with self.username_field.handler_block(self.username_change_signal):
            self.username_field.set_text('')

        self.email_field.set_text('')
        self.password_field.set_text('')
        self.password_confirm_field.set_text('')
        self.language_combo.set_active(0)        # triggers a "change" event, but it's okay
        self.phone_field.set_text('')

        self.submit_button.set_sensitive(False)

        self.first_name_field.grab_focus()


    def on_destroy(self, *args):
        Gtk.main_quit()


class WifiConnector:
    def __init__(self, builder, user_registration, register_frame):
        self.user_registration = user_registration
        self.register_frame = register_frame

        self.wifi_connector_box = builder.get_object('wifi_connector_box')
        self.wifi_connect_pid = None

        self.networks = {}
        self.network_choice_widget = builder.get_object('networks_list')
        self.network_choice_widget.connect('row-activated',
                                           self.wifi_connection_chosen)
        self.searching_for_networks = True

        self.password_entry = builder.get_object('network_password_entry')
        self.password_entry.connect('activate', self.connect_to_wifi)
        self.password_entry.connect('changed', self.password_changed)

        self.spinner = builder.get_object('network_connector_spinner')
        self.connection_status = builder.get_object('network_connection_status')

        self.connect_button = builder.get_object('network_connect_button')
        self.connect_button.connect('clicked', self.connect_to_wifi)

        self.network_ssid = None


    def activate(self):
        for child in self.register_frame.get_children():
            self.register_frame.remove(child)
        self.register_frame.add(self.wifi_connector_box)


    def password_changed(self, widget):
        wifi_password = self.password_entry.get_buffer().get_text()
        if wifi_password:
            self.connect_button.set_sensitive(True)
        else:
            self.connect_button.set_sensitive(False)


    def remove_all_wireless_connections(self):
        cmd = [ 'env', 'LANG=C', 'nmcli', '-t', '-f', 'NAME,TYPE',
                'connection', 'show' ]
        output = subprocess.check_output(cmd).rstrip().decode('utf-8')
        for connection_line in output.split("\n"):
            connection_line_fields = connection_line.split(':')
            if len(connection_line_fields) != 2:
                continue
            (connection_name, connection_type) = connection_line_fields
            if "wireless" in connection_type:
                cmd = [ 'nmcli', 'connection', 'delete', connection_name ]
                subprocess.run(cmd)


    def connect_to_wifi(self, widget):
        if not self.network_ssid:
            return
        if self.wifi_connect_pid:
            return

        # The connect operation always creates a new connection to
        # NetworkManager configuration even if it fails.  Clear up all
        # previous wireless connections (yes this is a big hammer).
        self.remove_all_wireless_connections()

        wifi_password = self.password_entry.get_buffer().get_text()

        cmd = [ '/usr/bin/env', 'LANG=C', 'nmcli', 'device', 'wifi', 'connect',
                self.network_ssid ]
        if wifi_password:
            cmd += [ 'password' ]
            cmd += [ wifi_password ]

        self.wifi_connect_output = ''

        flags = GLib.SPAWN_DO_NOT_REAP_CHILD|GObject.SPAWN_STDERR_TO_DEV_NULL
        (self.wifi_connect_pid, stdin, stdout, stderr) \
            = GObject.spawn_async(cmd, flags=flags, standard_output=True)

        fl = fcntl.fcntl(stdout, fcntl.F_GETFL)
        fcntl.fcntl(stdout, fcntl.F_SETFL, fl | os.O_NONBLOCK)

        GObject.io_add_watch(stdout,
                             GObject.IO_HUP|GObject.IO_IN,
                             self.wifi_connect_callback,
                             os.fdopen(stdout))

        self.connect_button.set_sensitive(False)
        self.spinner.start()
        self.connection_status.set_text('connecting to %s' % self.network_ssid)


    def wifi_connect_callback(self, fd, condition, channel):
        if condition & GObject.IO_IN:
            self.wifi_connect_output += channel.read()

        if condition & GObject.IO_HUP:
            channel.close()
            (pid, status) = os.waitpid(self.wifi_connect_pid, 0)
            self.wifi_connect_pid = None
            self.spinner.stop()

            # status should be > 0 in case of error, but it is not,
            # so instead we look at the output :-(
            if "successfully activated" in self.wifi_connect_output:
                self.connection_status.set_text(_tr('connection successful'))
                self.user_registration.activate()
            else:
                self.connection_status.set_text(
                  _tr('error connecting to network'))
                self.remove_all_wireless_connections()
            self.wifi_connect_output = ''

            return False

        return True


    def wifi_connection_chosen(self, listbox, row):
        for network_ssid, network_info in self.networks.items():
            if network_info['widget'] == row:
                self.network_ssid = network_ssid
                break

        network_info = self.networks[self.network_ssid]
        self.password_entry.set_text('')
        if network_info['security']:
            self.connect_button.set_sensitive(False)
            self.password_entry.grab_focus()
            self.password_entry.set_sensitive(True)
        else:
            self.connect_button.grab_focus()
            self.connect_button.set_sensitive(True)
            self.password_entry.set_sensitive(False)


    def ask_if_wireless_network_is_wanted(self, app_window):
        short_msg = _tr('Join wireless network?')
        long_msg = _tr('You are connected to a network that is not a' \
                         + ' wireless network.  Do you want to join'  \
                         + ' a wireless network?')
        dialog = Gtk.MessageDialog(app_window, 0, Gtk.MessageType.QUESTION,
            Gtk.ButtonsType.YES_NO, short_msg)
        dialog.format_secondary_text(long_msg)
        response = dialog.run()
        dialog.destroy()
        return response == Gtk.ResponseType.YES


    def ask_if_wifi_network_is_okay(self, app_window, network_ssid):
        short_msg = _tr('Use network "%s"?') % network_ssid
        long_msg = _tr('You are connected to network "%s",' \
                         + ' do you want to use this network?')) % network_ssid
        dialog = Gtk.MessageDialog(app_window, 0, Gtk.MessageType.QUESTION,
            Gtk.ButtonsType.YES_NO, short_msg)
        dialog.format_secondary_text(long_msg)
        response = dialog.run()
        dialog.destroy()
        return response == Gtk.ResponseType.YES


    def check_network_connectivity(self):
        # XXX how are exceptions handled, for example here?
        cmd = [ 'env', 'LANG=C', 'nmcli', 'networking', 'connectivity' ]
        output = subprocess.check_output(cmd).rstrip().decode('utf-8')
        return output == 'full'


    def prepare_ui_and_activate(self, app_window):
        cmd = [ 'nmcli', 'radio', 'wifi', 'on' ]
        output = subprocess.run(cmd)

        wireless_active = False
        self.update_networks_info()
        for network_ssid, network_info in self.networks.items():
            if network_info['active']:
                wireless_active = True
                if self.ask_if_wifi_network_is_okay(app_window, network_ssid):
                    self.user_registration.activate()
                    return
                break

        if not wireless_active and self.check_network_connectivity():
            if not self.ask_if_wireless_network_is_wanted(app_window):
                self.user_registration.activate()
                return

        GObject.timeout_add_seconds(8, self.update_networks_info)

        self.activate()


    def update_networks_info(self):
        new_networks = {}

        cmd = [ 'env', 'LANG=C', 'nmcli', '-t', '-f',
                'SSID,ACTIVE,SIGNAL,SECURITY', 'dev', 'wifi', 'list' ]
        output = subprocess.check_output(cmd).rstrip().decode('utf-8')
        for network_line in output.split("\n"):
            network_line_fields = network_line.split(':')
            if len(network_line_fields) != 4:
                continue

            (ssid, active_str, signal, security) = network_line_fields
            active = False
            if active_str == 'yes':
                active = True

            if not ssid in new_networks:
                new_networks[ssid] = { 'active':   active,
                                       'signal':   0,
                                       'security': security }
            if not new_networks[ssid]['active']:
                new_networks[ssid]['active'] = active
            if not new_networks[ssid]['security']:
                new_networks[ssid]['security'] = security
            try:
                max_signal = max(int(signal), new_networks[ssid]['signal'])
                new_networks[ssid]['signal'] = max_signal
            except ValueError:
                pass

        sorted_by_signal = sorted(new_networks,
                                  key=lambda x: new_networks.get(x)['signal'],
                                  reverse=True)

        # add new interface elements
        for network_ssid in sorted_by_signal:
            if network_ssid in self.networks:
                continue
            row = Gtk.ListBoxRow()
            label = Gtk.Label(label=network_ssid)
            row.add(label)
            self.network_choice_widget.add(row)
            self.networks[network_ssid] = new_networks[network_ssid]
            self.networks[network_ssid]['widget'] = row

        # remove old interface elements
        for network_ssid in self.networks.copy():
            if network_ssid in new_networks:
                continue
            self.networks[network_ssid]['widget'].destroy()
            del self.networks[network_ssid]
            if self.network_ssid == network_ssid:
               self.network_ssid = None

        # choose first network in case self.network_ssid is not set
        for network_ssid in sorted_by_signal:
            if not self.network_ssid:
                row = self.networks[network_ssid]['widget']
                self.network_choice_widget.select_row(row)
                # this sets self.network_ssid:
                self.wifi_connection_chosen(self.network_choice_widget, row)

        if len(self.networks) == 0:
            self.spinner.start()
            self.connection_status.set_text('searching for networks')
            self.searching_for_networks = True
        elif self.searching_for_networks:
            self.spinner.stop()
            self.connection_status.set_text('')
            self.searching_for_networks = False

        self.network_choice_widget.show_all()

        return True


class NetworkThread(threading.Thread):
    def __init__(self, json, event):
        super().__init__()
        self.json = json
        self.event = event
        self.response = {}


    def run(self):
        self.response['failed'] = False
        self.response['error'] = None

        response = None

        # XXX ip address should change to something stable/configurable
        conn = http.client.HTTPConnection('10.246.133.169', 9491, timeout=10)

        headers = {
            'Content-type': 'application/json',
        }

        try:
            conn.request('POST',
                         '/register_user',
                         body=bytes(self.json, 'utf-8'),
                         headers=headers)

            # Must read the response here, because the "finally" handler
            # closes the connection and that happens before we can read
            # the response
            response = conn.getresponse()
            self.response['code'] = response.status
            self.response['headers'] = response.getheaders()
            self.response['data'] = response.read()

        except socket.timeout as st:
            self.response['error'] = 'timeout'
            self.response['failed'] = True
        except http.client.HTTPException as e:
            self.response['error'] = e
            self.response['failed'] = True
        except Exception as e:
            self.response['error'] = e
            self.response['failed'] = True
        finally:
            conn.close()

        self.event.set()
        print('Network thread exiting')

at_session_startup = False
if len(sys.argv) == 1:
    pass
elif len(sys.argv) == 2:
    if sys.argv[1] != '--at-session-startup':
        usage()
    at_session_startup = True
else:
    usage()


builder = Gtk.Builder()
builder.add_from_file('/usr/share/puavo-user-registration/puavo-user-registration.glade')

app_window = builder.get_object('register_window')
register_frame = builder.get_object('register_frame')
if at_session_startup:
    go_to_desktop_button = builder.get_object('go_to_desktop')
    go_to_desktop_button.show()
    go_to_desktop_button.connect('clicked',
                                 lambda x: go_to_desktop(app_window, x))

user_registration = UserRegistration(builder, app_window, register_frame,
                                     at_session_startup)

if at_session_startup:
    wifi_connector = WifiConnector(builder, user_registration, register_frame)
    wifi_connector.prepare_ui_and_activate(app_window)
    app_window.set_decorated(False)
    app_window.set_deletable(False)
    app_window.set_skip_pager_hint(True)
    app_window.set_skip_taskbar_hint(True)
else:
    user_registration.activate()

app_window.show_all()

Gtk.main()
