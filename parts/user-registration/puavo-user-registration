#!/usr/bin/python3

# New user registration dialog v0.5

# TODO:
#  - everything

import gi
import http.client
import json
import os
import re
import socket
import subprocess
import threading
import time
import unicodedata
import sys

gi.require_version('Gtk', '3.0')
from gi.repository import GLib, Gtk, GObject


# Used when interpreting a failed server response
FIELD_ERRORS = {
    'first_name': {
        'name': 'etunimi',
        'reasons': {
            'empty': 'on tyhjä',
            'failed_validation': 'sisältää virheellisiä merkkejä',
        }
    },

    'last_name': {
        'name': 'sukunimi',
        'reasons': {
            'empty': 'on tyhjä',
            'failed_validation': 'sisältää virheellisiä merkkejä',
        }
    },

    'username': {
        'name': 'käyttäjänimi',
        'reasons': {
            'empty': 'on tyhjä',
            'failed_validation': 'sisältää virheellisiä merkkejä',
        }
    },

    'email': {
        'name': 'email',
        'reasons': {
            'empty': 'on tyhjä',
            'failed_validation': 'sisältää virheellisiä merkkejä',
        }
    },

    'phone': {
        'name': 'puhelinnumero',
        'reasons': {
            'empty': 'on tyhjä',
            'failed_validation': 'sisältää virheellisiä merkkejä',
            'too_long': 'on liian pitkä',
        }
    },
}

# These language codes must be the same that are configured/allowed on the server!
LANGUAGES = [
    ('fi_FI.UTF-8', 'Suomi'),
    ('sv_FI.UTF-8', 'Ruotsi'),
    ('en_US.UTF-8', 'Englanti'),
    ('de_CH.UTF-8', 'Saksa'),
]

USERNAME_FILTER = re.compile(r'[^a-z|0-9|.|\-|_]')


def go_to_desktop(app_window, widget):
    dialog = Gtk.MessageDialog(app_window, 0, Gtk.MessageType.WARNING,
       Gtk.ButtonsType.OK_CANCEL, "Go to desktop?")
    dialog.format_secondary_text("Are you sure you do not want to create a user account?  Without user account, your files will be lost after your desktop session ends.")
    response = dialog.run()
    if response == Gtk.ResponseType.OK:
        Gtk.main_quit()
        sys.exit(0)
    dialog.destroy()


def usage():
    print("usage: puavo-user-registration [--at-session-startup]",
          file=sys.stderr)
    sys.exit(1)


class UserRegistration:
    def __init__(self, builder, register_frame):
        self.builder = builder
        self.register_frame = register_frame

        # Get object handles
        self.register_user_box = self.builder.get_object('register_user')
        self.first_name_field  = self.builder.get_object('first_name')
        self.last_name_field   = self.builder.get_object('last_name')
        self.username_field    = self.builder.get_object('username')
        self.username_hint     = self.builder.get_object('username_hint')
        self.email_field       = self.builder.get_object('email')
        self.password_field    = self.builder.get_object('password')
        self.password_confirm_field \
            = self.builder.get_object('password_confirm')
        self.language_combo    = self.builder.get_object('language')
        self.phone_field       = self.builder.get_object('phone_number')
        self.spinner           = self.builder.get_object('registration_spinner')
        self.status            = self.builder.get_object('status_message')

        self.submit_button = self.builder.get_object('submit')
        self.reset_button  = self.builder.get_object('reset')

        self.username_change_signal = -1

        self.network_thread = None
        self.network_thread_event = None

        # Setup initial values
        for lang in LANGUAGES:
            self.language_combo.insert(-1, lang[0], lang[1])

        self.language_combo.set_active(0)

        # Setup event handling
        handlers = {
            'on_first_name_changed': self.on_first_name_changed,
            'on_last_name_changed': self.on_last_name_changed,
            'on_username_changed': self.on_username_changed,
            'on_email_changed': self.on_email_changed,
            'on_password_changed': self.on_password_changed,
            'on_password_confirm_changed': self.on_password_confirm_changed,
            'on_language_changed': self.on_language_changed,
            'on_phone_number_changed': self.on_phone_number_changed,

            'on_submit_clicked': self.on_submit_clicked,
            'on_reset_clicked': self.on_reset_clicked,

            'on_destroy': self.on_destroy,
        }

        self.builder.connect_signals(handlers)

        # Manually bind this event because we need the signal ID and
        # connect_signals() won't return them
        self.username_change_signal \
            = self.username_field.connect('changed', self.on_username_changed)

        self.set_username_hint_status(True)
        self.set_submit_state()
        self.status.set_text('')


    def activate(self):
        for child in self.register_frame.get_children():
            self.register_frame.remove(child)
        self.register_frame.add(self.register_user_box)


    def show_info_message(self, parent, message, secondary_message=None):
        """Show a modal information message box."""

        dialog = Gtk.MessageDialog(parent=parent,
                                   flags=Gtk.DialogFlags.MODAL,
                                   type=Gtk.MessageType.INFO,
                                   buttons=Gtk.ButtonsType.OK,
                                   message_format=message)

        if secondary_message:
            dialog.format_secondary_markup(secondary_message)

        dialog.run()
        dialog.hide()


    def show_error_message(self, parent, message, secondary_message=None):
        """Show a modal error message box."""

        dialog = Gtk.MessageDialog(parent=parent,
                                   flags=Gtk.DialogFlags.MODAL,
                                   type=Gtk.MessageType.ERROR,
                                   buttons=Gtk.ButtonsType.OK,
                                   message_format=message)

        if secondary_message:
            dialog.format_secondary_markup(secondary_message)

        dialog.run()
        dialog.hide()


    def set_username_hint_status(self, is_good=True):
        color = '#888' if is_good else '#f00'
        self.username_hint.set_markup('<span color="%s">Käyttäjätunnuksiin kelpaavat merkit a-z, 0-9, -, _ ja piste.</span>' % color)


    def set_submit_state(self):
        state = True

        if len(self.first_name_field.get_text().strip()) == 0:
            state = False

        if len(self.last_name_field.get_text().strip()) == 0:
            state = False

        if len(self.username_field.get_text().strip()) == 0 or \
          re.search(USERNAME_FILTER, self.username_field.get_text()):
            state = False

        if len(self.email_field.get_text().strip()) == 0:
            state = False

        if len(self.password_field.get_text()) == 0:
            state = False

        if len(self.password_confirm_field.get_text()) == 0:
            state = False

        if self.password_field.get_text() != self.password_confirm_field.get_text():
            state = False

        self.submit_button.set_sensitive(state)


    def enable_inputs(self, state):
        for obj in self.builder.get_objects():
            if obj is self.status:
                continue

            if isinstance(obj, Gtk.Entry) or \
               isinstance(obj, Gtk.Label) or \
               isinstance(obj, Gtk.Button) or \
               isinstance(obj, Gtk.ComboBoxText):
                obj.set_sensitive(state)


    def update_username(self):
        fn = self.first_name_field.get_text().strip()
        ln = self.last_name_field.get_text().strip()

        if len(fn) == 0 and len(ln) == 0:
            username = ''
        elif len(fn) > 0 and len(ln) == 0:
            username = fn
        elif len(fn) == 0 and len(ln) > 0:
            username = ln
        else:
            username = fn + '.' + ln

        username = username.lower()

        # Decompose Unicode into separate combining characters
        username = unicodedata.normalize('NFD', username)

        # Then remove all bytes outside of the a-z/number/some punctuation range.
        # All accents, diacritics, etc. will disappear, leaving only unaccented
        # characters behind.
        username = re.sub(USERNAME_FILTER, r'', username)

        # Update the username without triggering a "changed" event
        with self.username_field.handler_block(self.username_change_signal):
            self.username_field.set_text(username)


    def on_first_name_changed(self, edit):
        self.update_username()
        self.set_submit_state()


    def on_last_name_changed(self, edit):
        self.update_username()
        self.set_submit_state()


    def on_username_changed(self, edit):
        username = edit.get_text()

        if re.search(USERNAME_FILTER, username):
            self.set_username_hint_status(False)
        else:
            self.set_username_hint_status(True)

        self.set_submit_state()


    def on_email_changed(self, edit):
        self.set_submit_state()


    def on_password_changed(self, edit):
        self.set_submit_state()


    def on_password_confirm_changed(self, edit):
        self.set_submit_state()


    def on_language_changed(self, combo):
        self.set_submit_state()


    def on_phone_number_changed(self, edit):
        self.set_submit_state()


    def handle_server_error(self, response):
        self.show_error_message(self.window, 'Virhe',
           'Palvelinpäässä meni jokin pieleen. Ole hyvä ja ota yhteys tukeen. '
           'Anna tuelle tämä koodi:\n\n<big>{0}</big>'.format(response['log_id']))


    def handle_server_400(self, response):
        if response['status'] == 'missing_data':
            if len(response['failed_fields']) > 0:
                msg = 'Näiden kenttien sisällössä on jotain vikaa. Tarkista niiden sisältö ' \
                      'ja yritä uudelleen.\n\n'

                for field in response['failed_fields']:
                    error = FIELD_ERRORS[field['name']]
                    msg += '- {0} {1}\n'.format(error['name'], error['reasons'][field['reason']])

                self.show_error_message(self.window,'Virheelliset tiedot', msg)

        elif response['status'] == 'malformed_json':
            # *we* sent invalid data :-(
            self.show_error_message(self.window, 'Virheelliset tiedot',
                               'Rekisteröintiohjelma lähetti palvelimelle virheellisiä tietoja. '
                               'Ole hyvä ja ota yhteys tukeen. Anna tuelle tämä koodi:\n\n'
                               '<big>{0}</big>'.format(response['log_id']))

        elif response['status'] == 'incomplete_data':
            # *we* sent incomplete/missing data :-(
            self.show_error_message(self.window, 'Puutteelliset tiedot',
                               'Rekisteröintiohjelma lähetti palvelimelle puutteellisia tietoja. '
                               'Ole hyvä ja ota yhteys tukeen. Anna tuelle tämä koodi:\n\n'
                               '<big>{0}</big>'.format(response['log_id']))

        elif response['status'] == 'invalid_username':
            self.show_error_message(self.window, 'Virheellinen data',
                               'Käyttäjätunnus sisältää virheellisiä merkkejä.')

        elif response['status'] == 'invalid_email':
            self.show_error_message(self.window, 'Virheellinen data',
                               'Sähköpostiosoite ei ole kunnollinen.')

        elif response['status'] == 'password_mismatch':
            self.show_error_message(self.window, 'Virheellinen data',
                               'Salasana ja sen varmistus eivät täsmää.')

        elif response['status'] == 'invalid_language':
            self.show_error_message(self.window, 'Virheellinen data',
                               'Kieli on virheellinen.')

        else:
            self.show_error_message(self.window, 'Virhe',
               'Käyttäjätietojen käsittelyssä tapahtui tuntematon virhe. '
               'Ota yhteys tukeen ja anne heille tämä koodi:\n\n'
               '<big>{0}</big>'.format(response['log_id']))


    def handle_server_401(self, response):
        if response['status'] == 'unknown_machine':
            # This machine does not exist in the database
            self.show_error_message(self.window, 'Rekisteröimätön kone',
                'Koneesi tietoja ei löydy tietokannasta. Ole hyvä ja ota '
                'yhteys tukeen. Anna tuelle tämä koodi:\n\n<big>{0}</big>'.
                format(response['log_id']))

        elif response['status'] == 'device_already_in_use':
            # This machine already has a user. THIS SHOULD NOT HAPPEN.
            self.show_error_message(self.window, 'Kone on jo käytössä',
                'Tältä koneelta on jo suoritettu käyttäjän luonti. Ole hyvä ja ota '
                'yhteys tukeen. Anna tuelle tämä koodi:\n\n<big>{0}</big>'.
                format(response['log_id']))

        elif response['status'] == 'server_error':
            self.handle_server_error(response)

        else:
            self.show_error_message(self.window, 'Virhe',
               'Laitetietojen käsittelyssä tapahtui tuntematon virhe. '
               'Ota yhteys tukeen ja anne heille tämä koodi:\n\n'
               '<big>{0}</big>'.format(response['log_id']))


    def handle_server_409(response):
        if response['status'] == 'username_unavailable':
            self.show_error_message(self.window, 'Käyttäjätunnus on jo käytössä',
                'Valitsemasi käyttäjätunnus on jo käytössä. Valitse toinen nimi.')

        elif response['status'] == 'duplicate_email':
            self.show_error_message(self.window, 'Sähköpostiosoite on jo käytössä',
                'Tämä sähköpostiosoite on jo käytössä. Käytä toista osoitetta.\n\n'
                'Jos toisen osoitteen käyttö ei ole mahdollista, ota yhteys tukeen. '
                'Anna heille tämä koodi:\n\n'
                '<big>{0}</big>'.format(response['log_id']))

        else:
            self.show_error_message(self.window, 'Virhe',
               'Käyttäjätietojen käsittelyssä tapahtui tuntematon virhe. '
               'Ota yhteys tukeen ja anne heille tämä koodi:\n\n<big>{0}</big>'.
               format(response['log_id']))


    def handle_server_500(self, response):
        self.handle_server_error(response)


    def handle_network_error(self, msg):
        self.show_error_message(self.window, 'Virhe',
            'Palvelimeen ei saada yhteyttä:\n\n\t{0}\n\n'
            'Tarkista verkkoyhteyden tila ja yritä uudelleen. Jos ongelma toistuu,'
            'ota yhteys tukeen.'.format(msg))


    def idle_func(self, event, thread):
        if event.is_set():
            print('Thread event set, idle function is exiting')
            self.status.set_text('')
            self.spinner.stop()

            if thread.response['failed']:
                if thread.response['error'] == 'timeout':
                    self.show_error_message(self.window, 'Virhe',
                        'Palvelin ei vastaa pyyntöön. Yritä lähetystä uudelleen hetken kuluttua. '
                        'Jos tilanne toistuu, ota yhteys tukeen.')
                else:
                    self.handle_network_error(thread.response['error'])
            else:
                self.interpret_server_response(
                    thread.response['code'],
                    thread.response['headers'],
                    thread.response['data'])

            self.enable_inputs(True)

            # Remove the idle function
            return False

        # Don't make CPU fans spin. This idle function is called where there
        # are no other messages to handle and that includes the server response
        # waiting. It's a long time to listen to CPU fans whirring...
        time.sleep(0.05)

        # Don't remove the idle function yet
        return True


    def interpret_server_response(self, response_code, response_headers,
      response_data):
        # Parse the returned JSON
        try:
            print('Trying to parse server response |{0}|'.format(response_data))
            server_data = response_data.decode('utf-8')
            server_json = json.loads(server_data)
        except Exception as e:
            self.show_error_message(self.window, 'Virhe',
                'Palvelimen lähettämää vastausta ei pystytty tulkitsemaan.\n\n'
                'Ole hyvä ja ota yhteys tukeen.')
            self.enable_inputs(True)
            return

        try:
            if response_code == 400:            # missing/incomplete/invalid data
                self.handle_server_400(server_json)
                self.enable_inputs(True)
                return
            elif response_code == 401:          # device errors
                self.handle_server_401(server_json)
                self.enable_inputs(True)
                return
            elif response_code == 409:          # unavailable username/email
                self.handle_server_409(server_json)
                self.enable_inputs(True)
                return
            elif response_code == 500:          # server errors
                self.handle_server_500(server_json)
                self.enable_inputs(True)
                return
            elif response_code == 200:          # the good response
                self.show_info_message(self.window,
                    'Tunnus luotu',
                    'Tunnuksesi on luotu. Voit aloittaa koneen käytön.\n\nMukavia hetkiä opiskelun pariin!')
                self.enable_inputs(True)

                # Quit
                Gtk.main_quit()

                return

            # All other return codes fall through to the "should not get here"
            # block below

        except Exception as e:
            self.show_error_message(self.window,
                'Jokin meni pieleen',
                'Palvelimen palauttamaa viestiä ei pystytty tulkitsemaan. Ole hyvä ja ota yhteys tukeen.')
            return

        # If we get here, something has gone horribly wrong
        self.show_error_message(self.window,
            'Jokin meni pieleen',
            'Tätä viestiä ei pitäisi tulla. Koska luet sitä nyt, on jokin mennyt pahasti pieleen.'
            'Ole hyvä ja ota yhteys tukeen.')


    def on_submit_clicked(self, button):
        # --------------------------------------------------------------------------
        # Gather data

        user = {}
        user['first_name'] = self.first_name_field.get_text().strip()
        user['last_name'] = self.last_name_field.get_text().strip()
        user['username'] = self.username_field.get_text()
        user['email'] = self.email_field.get_text().strip()
        user['password'] = self.password_field.get_text()
        user['password_confirm'] = self.password_confirm_field.get_text()
        user['language'] = LANGUAGES[self.language_combo.get_active()][0]
        user['phone'] = self.phone_field.get_text().strip()

        machine = {}

        try:
            machine['dn'] = open('data/dn', 'rb').read().decode('utf-8').strip()
            machine['password'] = open('data/password', 'rb').read().decode('utf-8').strip()
            machine['hostname'] = open('data/hostname', 'rb').read().decode('utf-8').strip()
        except Exception as e:
            print(e)

        data = {}
        data['user'] = user
        data['machine'] = machine

        json_data = json.dumps(data, ensure_ascii=False)

        # --------------------------------------------------------------------------
        # Launch a background thread

        self.status.set_text('Lähetetään tiedot palvelimelle...')
        self.enable_inputs(False)
        self.spinner.start()

        self.network_thread_event = threading.Event()

        self.network_thread = NetworkThread(json_data,
                                            self.network_thread_event)
        self.network_thread.daemon = True
        self.network_thread.start()

        # This will interpret the server's response
        GLib.idle_add(self.idle_func, self.network_thread_event,
            self.network_thread)


    def on_reset_clicked(self, button):
        self.first_name_field.set_text('')
        self.last_name_field.set_text('')

        with self.username_field.handler_block(self.username_change_signal):
            self.username_field.set_text('')

        self.email_field.set_text('')
        self.password_field.set_text('')
        self.password_confirm_field.set_text('')
        self.language_combo.set_active(0)        # triggers a "change" event, but it's okay
        self.phone_field.set_text('')

        self.submit_button.set_sensitive(False)

        self.first_name_field.grab_focus()


    def on_destroy(self, *args):
        Gtk.main_quit()


class WifiConnector:
    def __init__(self, builder, user_registration, register_frame):
        self.user_registration = user_registration
        self.register_frame = register_frame

        self.wifi_connector_box = builder.get_object('wifi_connector_box')
        self.wifi_connect_pid = None

        self.network_choice_widget = builder.get_object('networks_list')
        self.network_choice_widget.connect('row-activated',
                                           self.wifi_connection_chosen)

        self.password_entry = builder.get_object('network_password_entry')
        self.password_entry.connect('activate', self.connect_to_wifi)
        self.password_entry.connect('changed', self.password_changed)

        self.spinner = builder.get_object('network_connector_spinner')

        self.connect_button = builder.get_object('network_connect_button')
        self.connect_button.connect('clicked', self.connect_to_wifi)

        self.network_ssid = None


    def activate(self):
        for child in self.register_frame.get_children():
            self.register_frame.remove(child)
        self.register_frame.add(self.wifi_connector_box)


    def password_changed(self, widget):
        wifi_password = self.password_entry.get_buffer().get_text()
        if wifi_password:
            self.connect_button.set_sensitive(True)
        else:
            self.connect_button.set_sensitive(False)


    def connect_to_wifi(self, widget):
        if not self.network_ssid:
            return
        wifi_password = self.password_entry.get_buffer().get_text()

        cmd = [ '/usr/bin/nmcli', 'device', 'wifi', 'connect',
                self.network_ssid, 'password', wifi_password ]
        flags = GLib.SPAWN_DO_NOT_REAP_CHILD|GObject.SPAWN_STDERR_TO_DEV_NULL
        (self.wifi_connect_pid, stdin, stdout, stderr) \
            = GObject.spawn_async(cmd, flags=flags, standard_output=True)

        GObject.io_add_watch(stdout,
                             GObject.IO_HUP,
                             self.wifi_connect_callback,
                             os.fdopen(stdout))

        self.connect_button.set_sensitive(False)
        self.spinner.start()


    def wifi_connect_callback(self, fd, condition, channel):
        channel.close()
        (pid, status) = os.waitpid(self.wifi_connect_pid, 0)
        if status == 0:
            self.user_registration.activate()
        else:
            pass # XXX error message somewhere


    def wifi_connection_chosen(self, listbox, row):
        self.network_ssid = self.networks_by_widgets[row]
        network_info = self.networks[self.network_ssid]
        self.password_entry.grab_focus()
        self.password_entry.set_text('')
        if network_info['security']:
            self.connect_button.set_sensitive(False)
            self.password_entry.set_sensitive(True)
        else:
            self.connect_button.set_sensitive(True)
            self.password_entry.set_sensitive(False)


    def ask_if_wireless_network_is_wanted(self, app_window):
        short_msg = 'Use current network?'
        long_msg = 'You are connected to a network that is not a' \
                     + ' wireless network.  Do you want to join'  \
                     + ' a wireless network?'
        dialog = Gtk.MessageDialog(app_window, 0, Gtk.MessageType.QUESTION,
            Gtk.ButtonsType.YES_NO, short_msg)
        dialog.format_secondary_text(long_msg)
        response = dialog.run()
        dialog.destroy()
        return response == Gtk.ResponseType.YES


    def ask_if_wifi_network_is_okay(self, app_window, network_ssid):
        short_msg = 'Use network "%s"?' % network_ssid
        long_msg = ('You are connected to network "%s",' \
                      + ' do you want to use this network?') % network_ssid
        dialog = Gtk.MessageDialog(app_window, 0, Gtk.MessageType.QUESTION,
            Gtk.ButtonsType.YES_NO, short_msg)
        dialog.format_secondary_text(long_msg)
        response = dialog.run()
        dialog.destroy()
        return response == Gtk.ResponseType.YES


    def check_network_connectivity(self):
        # XXX how are exceptions handled, for example here?
        cmd = [ 'env', 'LANG=C', 'nmcli', 'networking', 'connectivity' ]
        output = subprocess.check_output(cmd).rstrip().decode('utf-8')
        return output == 'full'


    def prepare_ui_and_activate(self, app_window):
        wireless_active = False
        self.networks = self.get_networks_info()
        for network_ssid, network_info in self.networks.items():
            if network_info['active']:
                wireless_active = True
                if self.ask_if_wifi_network_is_okay(app_window, network_ssid):
                    self.user_registration.activate()
                    return
                break

        if not wireless_active and self.check_network_connectivity():
            if not self.ask_if_wireless_network_is_wanted(app_window):
                self.user_registration.activate()
                return

        self.networks_by_widgets = {}

        # XXX what if networks hash is empty?  (no wireless networks at all)

        sorted_by_signal = sorted(self.networks,
                                  key=lambda x: self.networks.get(x)['signal'],
                                  reverse=True)

        selected = False
        for ssid in sorted_by_signal:
            row = Gtk.ListBoxRow()
            label = Gtk.Label(label=ssid)
            row.add(label)
            self.network_choice_widget.add(row)
            self.networks_by_widgets[row] = ssid
            if not selected:
                self.network_choice_widget.select_row(row)
                self.wifi_connection_chosen(self.network_choice_widget, row)
                selected = True

        self.activate()


    def get_networks_info(self):
        cmd = [ 'env', 'LANG=C', 'nmcli', '-t', '-f',
                'SSID,ACTIVE,SIGNAL,SECURITY', 'dev', 'wifi', 'list' ]
        output = subprocess.check_output(cmd).rstrip().decode('utf-8')
        networks = {}
        for network_line in output.split("\n"):
            network_line_fields = network_line.split(':')
            if len(network_line_fields) != 4:
                continue

            (ssid, active_str, signal, security) = network_line_fields
            active = False
            if active_str == 'yes':
                active = True

            if not ssid in networks:
                networks[ssid] = { 'active':   active,
                                   'signal':   0,
                                   'security': security }
            try:
                max_signal = max(int(signal), networks[ssid]['signal'])
                networks[ssid]['signal'] = max_signal
            except ValueError:
                pass

        return networks



class NetworkThread(threading.Thread):
    def __init__(self, json, event):
        super().__init__()
        self.json = json
        self.event = event
        self.response = {}


    def run(self):
        self.response['failed'] = False
        self.response['error'] = None

        response = None

        # XXX ip address should change to something stable/configurable
        conn = http.client.HTTPConnection('10.246.133.169', 9491, timeout=10)

        headers = {
            'Content-type': 'application/json',
        }

        try:
            conn.request('POST',
                         '/register_user',
                         body=bytes(self.json, 'utf-8'),
                         headers=headers)

            # Must read the response here, because the "finally" handler
            # closes the connection and that happens before we can read
            # the response
            response = conn.getresponse()
            self.response['code'] = response.status
            self.response['headers'] = response.getheaders()
            self.response['data'] = response.read()

        except socket.timeout as st:
            self.response['error'] = 'timeout'
            self.response['failed'] = True
        except http.client.HTTPException as e:
            self.response['error'] = e
            self.response['failed'] = True
        except Exception as e:
            self.response['error'] = e
            self.response['failed'] = True
        finally:
            conn.close()

        self.event.set()
        print('Network thread exiting')

at_session_startup = False
if len(sys.argv) == 1:
    pass
elif len(sys.argv) == 2:
    if sys.argv[1] != '--at-session-startup':
        usage()
    at_session_startup = True
else:
    usage()


builder = Gtk.Builder()
builder.add_from_file('./puavo-user-registration.glade')        # XXX path

app_window = builder.get_object('register_window')
register_frame = builder.get_object('register_frame')
if at_session_startup:
    go_to_desktop_button = builder.get_object('go_to_desktop')
    go_to_desktop_button.show()
    go_to_desktop_button.connect('clicked',
                                 lambda x: go_to_desktop(app_window, x))

user_registration = UserRegistration(builder, register_frame)

if at_session_startup:
    wifi_connector = WifiConnector(builder, user_registration, register_frame)
    wifi_connector.prepare_ui_and_activate(app_window)
    app_window.set_decorated(False)
    app_window.set_deletable(False)
    app_window.set_skip_pager_hint(True)
    app_window.set_skip_taskbar_hint(True)
else:
    user_registration.activate()

app_window.show_all()

Gtk.main()
