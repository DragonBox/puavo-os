#!/bin/sh

# NOT using "set -eu", we want to control exit codes exactly.
# set -x; exec > /tmp/puavo-login.$$.log 2>&1	# for development debugging

# from /usr/include/security/_pam_types.h
PAM_SUCCESS=0
PAM_SYSTEM_ERR=4
PAM_PERM_DENIED=6
PAM_AUTHINFO_UNAVAIL=9

PUAVO_SESSION_DIR="/var/lib/puavo-desktop/users/${PAM_USER}"
PUAVO_SESSION_FILE="${PUAVO_SESSION_DIR}/puavo_session.json"

USER_MINIMUM_UID=10000

# XXX for development debugging
# env

# XXX DOCUMENTATION!
# XXX LOGGING!

mode="${1:-immediate}"

if [ -z "${KRB5CCNAME:-}" ]; then
  exit "$PAM_SYSTEM_ERR"
fi
export KRB5CCNAME

krb5_ticketpath="${KRB5CCNAME#FILE:}"

case "$PAM_TYPE" in
  auth)
    ;;
  close_session)
    rm -f "${krb5_ticketpath}" || exit "$PAM_SYSTEM_ERR"
    exit "$PAM_SUCCESS"
    ;;
  open_session)
    # guest session does not have "${krb5_ticketpath}"
    if [ -e "${krb5_ticketpath}" ]; then
      chown "${PAM_USER}:" "${krb5_ticketpath}" || exit "$PAM_SYSTEM_ERR"
    fi
    exit "$PAM_SUCCESS"
    ;;
  *)
    exit "$PAM_SYSTEM_ERR"
    ;;
esac

# now PAM_TYPE == "auth"

user_password=$(cat) || exit "$PAM_SYSTEM_ERR"

#
# main subroutines
#

authenticate_user() {
  authenticate_user_status=0
  kinit_msg=$(
    echo "$user_password" \
      | timeout -k 1 10 env LANG=C \
	  kinit -f -l 5d -r 7d "$PAM_USER" 2>&1) || authenticate_user_status=$?

  # May fail because uid may not be known yet.
  # "open_session" should fix that, but that is not enough
  # for every situation.
  chown "${PAM_USER}:" "${krb5_ticketpath}" 2>/dev/null || true

  if [ "$authenticate_user_status" -eq 0 ]; then
    return "$PAM_SUCCESS"
  fi

  if echo "$kinit_msg" \
    | grep -Eq '(not found in Kerberos database|Password incorrect)'; then
      return "$PAM_PERM_DENIED"
  fi

  return "$PAM_AUTHINFO_UNAVAIL"
}

check_user_uid() {
  user_uid="$(id -u "$1" 2>/dev/null)" || return 1

  [ "$user_uid" -ge "$USER_MINIMUM_UID" ]
}

get_puavo_session() {
  session_fetch_timeout="${1:-}"
  shift		# the rest of the arguments go to puavo-rest-request

  if [ -z "$session_fetch_timeout" ]; then
    session_fetch_timeout=40

    # If we have previous session data, keep the fetch timeout very short
    # because usually any session data we have is good enough.
    if [ -s "${PUAVO_SESSION_FILE}" ]; then
      session_fetch_timeout=4
    fi
  fi

  mkdir -p "$PUAVO_SESSION_DIR" || return 1

  session_status=0
  timeout -k 1 "$session_fetch_timeout" puavo-rest-request "$@" \
    > "${PUAVO_SESSION_FILE}.tmp" || session_status=$?

  if [ "$session_status" -eq 0 -a -s "${PUAVO_SESSION_FILE}.tmp" ]; then
    mv "${PUAVO_SESSION_FILE}.tmp" "${PUAVO_SESSION_FILE}" || true
  fi

  rm -f "${PUAVO_SESSION_FILE}.tmp"

  update_extrausers || return 1

  # If we have a puavo-session file, we have a success
  # (even if the file is old).
  [ -s "{PUAVO_SESSION_FILE}" ]
}

update_extrausers() {
  update_extrausers_status=0

  extrausers_new_passwd || update_extrausers_status=1
  extrausers_new_group  || update_extrausers_status=1

  return "$update_extrausers_status"
}

user_has_session() {
  timeout -k 1 10 loginctl user-status "$PAM_USER" >/dev/null 2>&1
}

#
# subroutines needed by update_extrausers
#

session_get_username() {
  jq -r '.user.username' "$PUAVO_SESSION_FILE"
}

session_get_user() {
  jq -r '
    .user.username
      + ":" + "x"
      + ":" + (.user.uid_number|tostring)
      + ":" + (.user.gid_number|tostring)
      + ":" + .user.first_name + " " + .user.last_name
      + ":" + "/home/" + .user.username
      + ":" + "/bin/bash"
  ' "$PUAVO_SESSION_FILE"
}

session_get_groups() {
  jq -r '
    .user.groups
    | map( .abbreviation + ":" + (.gid_number|tostring))
    | .[]
  ' "$PUAVO_SESSION_FILE"
}

extrausers_new_passwd() {
  passwd_file_path='/var/lib/extrausers/passwd'

  new_user="$(session_get_user)" || return 1
  [ -n "$new_user" ]             || return 1

  [ -e "$passwd_file_path" ] || touch "$passwd_file_path"

  new_passwd_data="$(
    echo "$new_user" | gawk -F: -v minimum_uid=10000 '
      # map users by uid, filter out duplicates,
      # possible adding the new user or modifying it
      $3 >= minimum_uid { users[$3] = $0 }
      END { for (user in users) { print users[user] } }
    ' "$passwd_file_path" /dev/stdin)" || return 1

  echo "$new_passwd_data" \
    | sort_and_replace_extrausers_file_from_stdin "$passwd_file_path"
}

extrausers_new_group() {
  group_file_path='/var/lib/extrausers/group'

  user_groups="$(session_get_groups)" || return 1
  username="$(session_get_username)"  || return 1

  [ -e "$group_file_path" ] || touch "$group_file_path"

  new_group_data="$(
    gawk -F: -v username="$username" \
             -v user_groups="$user_groups" \
             -v minimum_gid=10000 '
      # map groups by gid, filter out duplicates,
      # possible adding the user to some groups and removing from others

      BEGIN {
	user_group_count = split(user_groups, user_groups_array, "\n")
	for (i = 1; i <= user_group_count; i++) {
	  split(user_groups_array[i], newgroup_info, ":")
	  newgroup_name = newgroup_info[1]
	  newgroup_gid  = newgroup_info[2]

          if (newgroup_gid < minimum_gid) { continue }

	  new_groups_members[ newgroup_gid ] = username
	  new_groups_names[   newgroup_gid ] = newgroup_name
	}
      }

      {
	oldgroup_name = $1
	oldgroup_gid  = $3
	split($4, oldgroup_members, ",")

        if (oldgroup_gid < minimum_gid) { next }

	if (!(oldgroup_gid in new_groups_names)) {
	  new_groups_names[ oldgroup_gid ] = oldgroup_name
	}

	for (i in oldgroup_members) {
	  member_user = oldgroup_members[i]

	  # Filter out the current user... if it was not already listed in
	  # new_groups_members[oldgroup_gid], it must be deleted.
	  if (member_user == username) { continue }

	  new_groups_members[oldgroup_gid] =                       \
	    (new_groups_members[oldgroup_gid] == "")               \
	      ? member_user                                        \
	      : (new_groups_members[oldgroup_gid] "," member_user)
	}
      }

      END {
	for (gid in new_groups_names) {
          # drop groups with no members
	  if (new_groups_members[gid] == "") { continue }

	  members_list = ""
	  split(new_groups_members[gid], sorted_members_array, ",")
	  asort(sorted_members_array)

	  for (i in sorted_members_array) {
	    members_list =                                   \
	      (members_list == "")                           \
		? sorted_members_array[i]                    \
		: (members_list "," sorted_members_array[i])
	  }

	  printf("%s:x:%d:%s\n", new_groups_names[gid], gid, members_list)
	}
      }
    ' "$group_file_path")" || return 1

  echo "$new_group_data" \
    | sort_and_replace_extrausers_file_from_stdin "$group_file_path"
}

sort_and_replace_extrausers_file_from_stdin() {
  filepath="$1"

  # clean up possible old cruft
  for path in ${filepath}.tmp_*; do
    rm -f "$path"
  done

  extrausers_tempfile="$(mktemp "${filepath}.tmp_XXXXXX")" || return 1
  chmod 644 "$extrausers_tempfile" || return 1

  # data from stdin
  sort -k 3 -n -t ':' > "$extrausers_tempfile" || return 1

  if ! cmp "$extrausers_tempfile" "$filepath" 2>/dev/null; then
    mv "$extrausers_tempfile" "$filepath" || return 1
  else
    rm -f "$extrausers_tempfile"
  fi

  return 0
}

#
# main
#

if [ "$mode" = 'guest' ]; then
  # ignore session errors on guest user
  if [ -e /run/puavo/nbd-server ]; then
    get_puavo_session '' --user-bootserver v3/sessions || true
  else
    get_puavo_session '' --user-etc v3/sessions || true
  fi

  exit "$PAM_SUCCESS"
fi

if [ "$mode" = 'immediate' ]; then
  auth_status="$PAM_SUCCESS"
  authenticate_user || auth_status="$?"

  if [ "$auth_status" -ne "$PAM_SUCCESS" ]; then
    exit "$auth_status"
  fi

  # auth_status is now PAM_SUCCESS

  # Fetch user session information from puavo if auth was okay.
  if get_puavo_session '' --user-krb v3/sessions; then
    exit "$PAM_SUCCESS"
  fi

  # Either we have no session or update_extrausers failed.
  # That is serious only if $PAM_USER does not exist or is invalid.
  check_user_uid "$PAM_USER" || exit "$PAM_SYSTEM_ERR"

  mode='deferred-session-fetch'
fi

if [ "$mode" != 'cached-auth' -a "$mode" != 'deferred-session-fetch' ]; then
  exit "$PAM_SYSTEM_ERR"
fi

# cached-auth and deferred-session-fetch modes

# When gone through cached authentication, do extrausers update here as well,
# because we might have a case were we have a broken extrausers-database
# (should never happen), a successful auth through cached credentials, and
# proper user session information.
if [ "$mode" = 'cached-auth' ]; then
  update_extrausers || true
  check_user_uid "$PAM_USER" || exit "$PAM_SYSTEM_ERR"
fi

(
  # wait that user gets a login session
  for i in 1 2 4 8 16 32 64; do
    user_has_session && break
    sleep $i
  done

  while user_has_session; do
    auth_status="$PAM_SUCCESS"
    if [ "$mode" = 'cached-auth' ]; then
      authenticate_user || auth_status=$?
    fi

    if [ "$auth_status" -eq "$PAM_AUTHINFO_UNAVAIL" ]; then
      sleep 20
      continue
    fi

    if [ "$auth_status" -eq "$PAM_SUCCESS" ]; then
      # Fetch user session information from puavo if auth was okay.
      # It is not serious if we fail.  It is okay to wait for a longer
      # time, in deferred mode we do not delay logins.
      get_puavo_session 60 --user-krb v3/sessions || true
    fi

    exit "$auth_status"
  done

  exit "$PAM_AUTHINFO_UNAVAIL"
) &

exit "$PAM_SUCCESS"
