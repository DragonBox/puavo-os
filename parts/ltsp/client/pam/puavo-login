#!/bin/sh

# NOT using "set -eu", we want to control exit codes exactly,
# because pam_puavo expects them to be precisely meaningful.

# from /usr/include/security/_pam_types.h
PAM_SUCCESS=0
PAM_SYSTEM_ERR=4
PAM_PERM_DENIED=6
PAM_AUTHINFO_UNAVAIL=9

PUAVO_SESSION_DIR="/var/lib/puavo-desktop/users/${PAM_USER}"
PUAVO_SESSION_FILE="${PUAVO_SESSION_DIR}/puavo_session.json"

USER_MINIMUM_UID=10000

# XXX DOCUMENTATION!

if [ -z "$PAM_USER" ]; then
  logger -p auth.err -s -t puavo-login 'PAM_USER is not set'
fi

mode="${1:-immediate}"

logmsg() { logger -p "auth.$1" -t puavo-login "user ${PAM_USER} / mode $mode :: $2"; }

#
# main subroutines
#

authenticate_user() {
  authenticate_user_status=0
  kinit_msg=$(
    echo "$user_password" \
      | timeout -k 1 10 env LANG=C \
	  kinit -f -l 5d -r 7d "$PAM_USER" 2>&1) || authenticate_user_status=$?

  if [ "$authenticate_user_status" -eq 0 ]; then
    logmsg notice 'kerberos auth was SUCCESS'

    # If PAM_USER uid is known at this point, change ticket owner.
    # It is not known in the first login case, but "open_session" fixes that.
    # "open_session" is however not run in every situation, for example when
    # screen lock is opened.
    if check_user_uid; then
      if ! chown "${PAM_USER}:" "${krb5_ticketpath}" 2>/dev/null; then
	logmsg warning "could not chown ${krb5_ticketpath} at auth"
      fi
    fi

    return "$PAM_SUCCESS"
  fi

  if echo "$kinit_msg" \
    | grep -Eq '(not found in Kerberos database|Password incorrect)'; then
      logmsg notice 'kerberos auth was DENIED'
      logmsg notice 'removing cached credentials'	# up to pam_ccreds.so
      return "$PAM_PERM_DENIED"
  fi

  logmsg notice 'kerberos auth was UNAVAILABLE'

  return "$PAM_AUTHINFO_UNAVAIL"
}

check_user_uid() {
  user_uid="$(id -u "$PAM_USER" 2>/dev/null)" || return 1

  if [ "$user_uid" -lt "$USER_MINIMUM_UID" ]; then
    logmsg warning "login through puavo-login attempted with uid ${user_uid}"
    return 1
  fi

  return 0
}

get_puavo_session() {
  session_fetch_timeout="${1:-}"
  shift		# the rest of the arguments go to puavo-rest-request

  if [ -z "$session_fetch_timeout" ]; then
    session_fetch_timeout=40

    # If we have previous session data, keep the fetch timeout very short
    # because usually any session data we have is good enough.
    if [ -s "${PUAVO_SESSION_FILE}" ]; then
      session_fetch_timeout=4
    fi
  fi

  logmsg info "fetching new puavo session with timeout $session_fetch_timeout"

  mkdir -p "$PUAVO_SESSION_DIR" || return 1

  session_status=0
  session_error_msg=$(
    timeout -k 1 "$session_fetch_timeout" puavo-rest-request "$@" 2>&1 \
      > "${PUAVO_SESSION_FILE}.tmp") || session_status=$?

  if [ "$session_status" -eq 0 -a -s "${PUAVO_SESSION_FILE}.tmp" ]; then
    logmsg info 'fetched new puavo session'
    if ! mv "${PUAVO_SESSION_FILE}.tmp" "${PUAVO_SESSION_FILE}" 2>/dev/null; then
      logmsg err 'error putting new puavo session into place'
      session_status=1
    fi
  else
    logmsg warning "error fetching new puavo session: $session_error_msg"
  fi

  rm -f "${PUAVO_SESSION_FILE}.tmp"

  update_extrausers || return 1

  if [ ! -s "$PUAVO_SESSION_FILE" ]; then
    logmsg err 'we have no puavo session, not even an old one'
    return 1
  fi

  if [ "$session_status" -ne 0 ]; then
    logmsg info 'using old puavo session'
  fi

  # If we have a puavo-session file, we have a success
  # (even if the file is old).
  return 0
}

update_extrausers() {
  update_extrausers_status=0

  if ! extrausers_new_passwd; then
    logmsg err 'error updating extrausers passwd db'
    update_extrausers_status=1
  fi

  if ! extrausers_new_group; then
    logmsg err 'error updating extrausers group db'
    update_extrausers_status=1
  fi

  if [ "$update_extrausers_status" -eq 0 ]; then
    logmsg notice 'extrausers databases update done'
  fi

  return "$update_extrausers_status"
}

user_has_session() {
  timeout -k 1 10 loginctl user-status "$PAM_USER" >/dev/null 2>&1
}

#
# subroutines needed by update_extrausers
#

session_get_username() {
  jq -r '.user.username' "$PUAVO_SESSION_FILE"
}

session_get_user() {
  jq -r '
    .user.username
      + ":" + "x"
      + ":" + (.user.uid_number|tostring)
      + ":" + (.user.gid_number|tostring)
      + ":" + .user.first_name + " " + .user.last_name
      + ":" + "/home/" + .user.username
      + ":" + "/bin/bash"
  ' "$PUAVO_SESSION_FILE"
}

session_get_groups() {
  # XXX test what if groups are empty?
  jq -r '
    .user.groups
    | map( .abbreviation + ":" + (.gid_number|tostring))
    | .[]
  ' "$PUAVO_SESSION_FILE"
}

extrausers_new_passwd() {
  passwd_file_path='/var/lib/extrausers/passwd'

  if ! new_user="$(session_get_user)" || [ -z "$new_user" ]; then
    logmsg err 'could not find user information from puavo session'
    return 1
  fi

  if [ ! -e "$passwd_file_path" ]; then
    logmsg notice "setting up new ${passwd_file_path} file"
    if ! touch "$passwd_file_path" 2>/dev/null; then
      logmsg err "could not create ${passwd_file_path}"
      return 1
    fi
  fi

  new_passwd_data="$(
    echo "$new_user" | gawk -F: -v minimum_uid=10000 '
      # map users by uid, filter out duplicates,
      # possible adding the new user or modifying it
      $3 >= minimum_uid { users[$3] = $0 }
      END { for (user in users) { print users[user] } }
    ' "$passwd_file_path" /dev/stdin)" || {
      logmsg err 'error in creating new extrausers passwd db'
      return 1
   }

  if ! echo "$new_passwd_data" \
         | sort_and_replace_extrausers_file_from_stdin "$passwd_file_path"; then
    logmsg err 'error in replacing old extrausers passwd db with a new one'
    return 1
  fi

  return 0
}

extrausers_new_group() {
  group_file_path='/var/lib/extrausers/group'

  if ! user_groups="$(session_get_groups)" || [ -z "$user_groups" ]; then
    logmsg err 'could not get user groups from puavo session'
    return 1
  fi

  if ! username="$(session_get_username)" || [ -z "$username" ]; then
    logmsg err 'could not get user groups from puavo session'
    return 1
  fi

  if [ ! -e "$group_file_path" ]; then
    logmsg notice "setting up new ${group_file_path} file"
    if ! touch "$group_file_path" 2>/dev/null; then
      logmsg err "could not create ${group_file_path}"
      return 1
    fi
  fi

  new_group_data="$(
    gawk -F: -v username="$username" \
             -v user_groups="$user_groups" \
             -v minimum_gid=10000 '
      # map groups by gid, filter out duplicates,
      # possible adding the user to some groups and removing from others

      BEGIN {
	user_group_count = split(user_groups, user_groups_array, "\n")
	for (i = 1; i <= user_group_count; i++) {
	  split(user_groups_array[i], newgroup_info, ":")
	  newgroup_name = newgroup_info[1]
	  newgroup_gid  = newgroup_info[2]

          if (newgroup_gid < minimum_gid) { continue }

	  new_groups_members[ newgroup_gid ] = username
	  new_groups_names[   newgroup_gid ] = newgroup_name
	}
      }

      {
	oldgroup_name = $1
	oldgroup_gid  = $3
	split($4, oldgroup_members, ",")

        if (oldgroup_gid < minimum_gid) { next }

	if (!(oldgroup_gid in new_groups_names)) {
	  new_groups_names[ oldgroup_gid ] = oldgroup_name
	}

	for (i in oldgroup_members) {
	  member_user = oldgroup_members[i]

	  # Filter out the current user... if it was not already listed in
	  # new_groups_members[oldgroup_gid], it must be deleted.
	  if (member_user == username) { continue }

	  new_groups_members[oldgroup_gid] =                       \
	    (new_groups_members[oldgroup_gid] == "")               \
	      ? member_user                                        \
	      : (new_groups_members[oldgroup_gid] "," member_user)
	}
      }

      END {
	for (gid in new_groups_names) {
          # drop groups with no members
	  if (new_groups_members[gid] == "") { continue }

	  members_list = ""
	  split(new_groups_members[gid], sorted_members_array, ",")
	  asort(sorted_members_array)

	  for (i in sorted_members_array) {
	    members_list =                                   \
	      (members_list == "")                           \
		? sorted_members_array[i]                    \
		: (members_list "," sorted_members_array[i])
	  }

	  printf("%s:x:%d:%s\n", new_groups_names[gid], gid, members_list)
	}
      }
    ' "$group_file_path")" || {
      logmsg err 'error in creating new extrausers group db'
      return 1
  }

  if ! echo "$new_group_data" \
         | sort_and_replace_extrausers_file_from_stdin "$group_file_path"; then
    logmsg err 'error in replacing old extrausers group db with a new one'
    return 1
  fi

  return 0
}

sort_and_replace_extrausers_file_from_stdin() {
  filepath="$1"

  # clean up possible old cruft
  for path in ${filepath}.tmp_*; do
    rm -f "$path" || true
  done

  extrausers_tempfile="$(mktemp "${filepath}.tmp_XXXXXX")" || return 1
  chmod 644 "$extrausers_tempfile" || return 1

  # data from stdin
  sort -k 3 -n -t ':' > "$extrausers_tempfile" || return 1

  if ! cmp "$extrausers_tempfile" "$filepath" 2>/dev/null; then
    mv "$extrausers_tempfile" "$filepath" || return 1
    logmsg notice "updated extrausers db $filepath with changes"
  else
    logmsg info "no change in extrausers db $filepath"
    rm -f "$extrausers_tempfile"
  fi

  return 0
}

#
# main
#

if [ "$PAM_USER" = 'guest' -a "$mode" = 'guest' ]; then
  case "$PAM_TYPE" in
    auth)
      logmsg notice 'letting guest user in without further authentication'

      # Setup guest user in even in case of session errors.  Guest uid and gid
      # are hardcoded session information does not affect it, so session is not
      # really essential.  Besides guest account should work in every situation
      # if at all possible.
      if [ -e /run/puavo/nbd-server ]; then
	get_puavo_session '' --user-bootserver v3/sessions || true
      else
	get_puavo_session '' --user-etc v3/sessions || true
      fi

      exit "$PAM_SUCCESS"
      ;;
    close_session)
      logmsg info 'closing login session'
      exit "$PAM_SUCCESS"
      ;;
    open_session)
      logmsg info 'opening login session'
      exit "$PAM_SUCCESS"
      ;;
    *)
      logmsg err "unknown PAM_TYPE '${PAM_TYPE}'"
      ;;
  esac

  exit "$PAM_SYSTEM_ERR"
fi

# we are not a guest user

if [ "$mode" = 'cached-fail' ]; then
  logmsg notice 'cached credentials auth was DENIED'
  exit "$PAM_PERM_DENIED"
fi

if [ -z "${KRB5CCNAME:-}" ]; then
  logmsg err 'KRB5CCNAME is not set'
  exit "$PAM_SYSTEM_ERR"
fi
export KRB5CCNAME

krb5_ticketpath="${KRB5CCNAME#FILE:}"

case "$PAM_TYPE" in
  auth)
    ;;
  close_session)
    logmsg info 'closing login session'
    rm -f "${krb5_ticketpath}" || exit "$PAM_SYSTEM_ERR"
    exit "$PAM_SUCCESS"
    ;;
  open_session)
    logmsg info 'opening login session'
    if ! chown "${PAM_USER}:" "${krb5_ticketpath}" 2>/dev/null; then
      logmsg err "could not chown ${krb5_ticketpath} at open_session"
      exit "$PAM_SYSTEM_ERR"
    fi
    exit "$PAM_SUCCESS"
    ;;
  *)
    logmsg err "unknown PAM_TYPE '${PAM_TYPE}'"
    exit "$PAM_SYSTEM_ERR"
    ;;
esac

# now PAM_TYPE == "auth"

if ! user_password="$(cat)"; then
  logmsg err 'could not read user password'
  exit "$PAM_SYSTEM_ERR"
fi


if [ "$mode" = 'immediate' ]; then
  auth_status="$PAM_SUCCESS"
  authenticate_user || auth_status="$?"

  if [ "$auth_status" -ne "$PAM_SUCCESS" ]; then
    logmsg notice 'returning auth error'
    exit "$auth_status"
  fi

  # auth_status is now PAM_SUCCESS

  # Fetch user session information from puavo if auth was okay.
  if get_puavo_session '' --user-krb v3/sessions; then
    logmsg notice 'returning success'
    exit "$PAM_SUCCESS"
  fi

  # Either we have no session or update_extrausers failed.
  # That is serious only if $PAM_USER does not exist or is invalid.
  if ! check_user_uid; then
    logmsg err 'user id does not exist or is invalid'
    exit "$PAM_SYSTEM_ERR"
  fi

  logmsg notice 'problems in session fetch, attempting fetch in deferred mode'
  mode='deferred-session-fetch'
fi

if [ "$mode" != 'cached-auth' -a "$mode" != 'deferred-session-fetch' ]; then
  logmsg err 'internal error, mode is wrong'
  exit "$PAM_SYSTEM_ERR"
fi

# cached-auth and deferred-session-fetch modes

# When gone through cached authentication, do extrausers update here as well,
# because we might have a case were we have a broken extrausers-database
# (should never happen), a successful auth through cached credentials, and
# proper user session information.
if [ "$mode" = 'cached-auth' ]; then
  logmsg notice 'cached credentials auth was SUCCESS'

  update_extrausers || true
  if ! check_user_uid; then
    logmsg err 'user id does not exist or is invalid'
    exit "$PAM_SYSTEM_ERR"
  fi
fi

(
  if ! user_has_session; then
    logmsg info 'waiting for user login session'
    for i in 1 2 4 8 16 32 64; do
      if user_has_session; then
        logmsg info "user got session after $((2 * $i - 1)) seconds"
        break
      fi
      sleep $i
    done
  fi

  while true; do
    if ! user_has_session; then
      logmsg info 'user does not have a session, giving up'
      break
    fi

    auth_status="$PAM_SUCCESS"
    if [ "$mode" = 'cached-auth' ]; then
      logmsg info 'trying deferred authentication'
      authenticate_user || auth_status=$?
    fi

    if [ "$auth_status" -eq "$PAM_AUTHINFO_UNAVAIL" ]; then
      logmsg info 'authentication service is not available, waiting 20 seconds'
      sleep 20
      continue
    fi

    if [ "$auth_status" -eq "$PAM_SUCCESS" ]; then
      # Fetch user session information from puavo if auth was okay.
      # It is not serious if we fail.  It is okay to wait for a longer
      # time, in deferred mode we do not delay logins.

      logmsg info 'authentication was ok, trying deferred puavo session fetch'
      get_puavo_session 60 --user-krb v3/sessions || true
      logmsg info 'exiting from deferred mode'
    else
      logmsg info 'authentication failed, exiting from deferred mode'
    fi

    exit "$auth_status"
  done

  exit "$PAM_AUTHINFO_UNAVAIL"
) &

exit "$PAM_SUCCESS"
