#!/bin/sh

set -eu

lookup_ifdata() {
  if_data_arg=$1
  if_fieldname=$2
  if_name=$3

  if_data=$(ifdata "$if_data_arg" "$if_name" 2>/dev/null) || true
  if [ -z "$if_data" ]; then
    if_data=$(
      awk -v if_fieldname="$if_fieldname" -v if_name="$if_name" '
        $1 == "iface" && $2 == if_name { found_interface_section = 1 }
        found_interface_section && $1 == if_fieldname { print $2; exit 0 }
      ' /etc/network/interfaces /etc/network/interfaces.d/* 2>/dev/null) \
        || true
  fi

  if [ -z "$if_data" ]; then
    return 1
  fi

  printf "%s\n" "$if_data"
}

lookup_ip()      { lookup_ifdata -pa address "$1"; }
lookup_netmask() { lookup_ifdata -pn netmask "$1"; }

# XXX this should not be hardcoded to 10.XXX addresses!
arpazone='10.in-addr.arpa'

puavo_domain=$(cat /etc/puavo/domain 2>/dev/null) || true
if [ -z "$puavo_domain" ]; then
  echo 'Could not determine puavo domain from /etc/puavo/domain' >&2
  exit 1
fi

# XXX should 'ltsp0' really be hardcoded here?
ltsp0_ip=$(lookup_ip ltsp0 2>/dev/null) || true
if [ -z "$ltsp0_ip" ]; then
  echo 'Could not determine ltsp0 interface address' >&2
  exit 1
fi

if [ ! -e /var/lib/bind/puavo_domain ]; then
  install -o bind -g bind -m 644 /dev/null /var/lib/bind/puavo_domain.tmp
  cat <<EOF > /var/lib/bind/puavo_domain.tmp
\$ORIGIN .
\$TTL 0          ; no TTL
${puavo_domain}         IN SOA  ns1.${puavo_domain}. 20101209. (
                                2010088447 ; serial
                                28800      ; refresh (8 hours)
                                3600       ; retry (1 hour)
                                604800     ; expire (1 week)
                                38400      ; minimum (10 hours 40 minutes)
                                )
                        NS      ns1.${puavo_domain}.
\$ORIGIN ${puavo_domain}.
ns1                     A       ${ltsp0_ip}
EOF
  mv /var/lib/bind/puavo_domain.tmp /var/lib/bind/puavo_domain
fi

if [ ! -e /var/lib/bind/puavo_domain_reverse ]; then
  install -o bind -g bind -m 644 /dev/null \
         /var/lib/bind/puavo_domain_reverse.tmp
  cat <<EOF > /var/lib/bind/puavo_domain_reverse.tmp
\$ORIGIN .
\$TTL 0          ; no TTL
${arpazone}             IN SOA  ${puavo_domain}. root.${puavo_domain}. (
                                2010088664 ; serial
                                604800     ; refresh (1 week)
                                86400      ; retry (1 day)
                                2419200    ; expire (4 weeks)
                                604800     ; minimum (1 week)
                                )
                        NS      ${puavo_domain}.
\$ORIGIN .
EOF
  mv /var/lib/bind/puavo_domain_reverse.tmp /var/lib/bind/puavo_domain_reverse
fi

# Create nsupdate.key for ddns-updates.  We do create a new one for every
# boot, because this is only used internally for this server.  In case this
# ever changes later, the key should be put under /state and the old one
# should not be overwritten.
mkdir -m 750 -p /etc/dhcp/ddns-keys
install -o root -g root -m 640 /dev/null /etc/dhcp/ddns-keys/nsupdate.key.tmp
ddns-confgen -a hmac-md5 -q > /etc/dhcp/ddns-keys/nsupdate.key.tmp
mv /etc/dhcp/ddns-keys/nsupdate.key.tmp /etc/dhcp/ddns-keys/nsupdate.key

install -o root -g bind -m 640 /etc/dhcp/ddns-keys/nsupdate.key \
                               /etc/bind/nsupdate.key

install -o root -g bind -m 644 /dev/null /etc/bind/named.conf.local.tmp
cat <<EOF > /etc/bind/named.conf.local.tmp
//
// Do any local configuration here
//

// Consider adding the 1918 zones here, if they are not used in your
// organization
//include "/etc/bind/zones.rfc1918";

include "/etc/bind/nsupdate.key";

zone "${puavo_domain}" {
        type master;
        file "/var/lib/bind/puavo_domain";
        update-policy {
                grant ddns-key zonesub ANY;
        };
};

zone "${arpazone}" {
        type master;
        file "/var/lib/bind/puavo_domain_reverse";
        update-policy {
                grant ddns-key zonesub ANY;
        };
};
EOF
mv /etc/bind/named.conf.local.tmp \
   /etc/bind/named.conf.local
