#!/usr/bin/ruby

require 'ipaddress'

def lookup_ifdata_from_file(if_name, if_fieldname)
  interfaces_files = %w(/etc/network/interfaces) \
                       + Dir.glob('/etc/network/interfaces.d/*')
  interfaces_files.each do |file|
    found_interface = false
    IO.readlines(file).each do |line|
      key, value = * line.split
      case key
      when 'iface'
        found_interface = (value == if_name)
      when if_fieldname
        return value
      end
    end
  end

  return nil
end

def lookup_ifdata(if_name, if_fieldname, if_data_arg)
  if_data = %x(ifdata #{ if_data_arg } #{ if_name }).chomp
  if if_data.empty? then
    if_data = lookup_ifdata_from_file(if_name, if_fieldname)
  end

  return if_data
end

def lookup_address(if_name)
  lookup_ifdata(if_name, 'address', '-pa')
end

def lookup_netmask(if_name)
  lookup_ifdata(if_name, 'netmask', '-pn')
end

class Interface
  def initialize(if_name)
    address = lookup_address(if_name)
    raise "could not determine address for #{ if_name }" unless address

    netmask = lookup_netmask(if_name)
    raise "could not determine netmask for #{ if_name }" unless netmask

    @ip = IPAddress("#{ address }/#{ netmask }")
  end

  def subsubnets_prefix
    [ @ip.prefix.to_i + 4, 32 ].min
  end

  def all_16_subnets
    @ip.subnet(subsubnets_prefix)
  end

  def subnets_except_own
    own_ip = IPAddress("#{ @ip.address }/#{ subsubnets_prefix }")
    all_16_subnets.select { |sb| !sb.include?(own_ip) }
  end

  def dhcp_ranges
    previous_last_ip = nil
    ranges = []
    subnets_except_own.each do |subnet|
      if previous_last_ip.nil? \
        || (previous_last_ip.u32 + 3) != (subnet.first.u32) then
          ranges << [ subnet.first, subnet.last ]
      else
        ranges[-1][1] = subnet.last
      end

      previous_last_ip = ranges[-1][1]
    end

    ranges
  end
end

ltsp0 = Interface.new('ltsp0')
wlan0 = Interface.new('wlan0')

ltsp0.dhcp_ranges.each do |range|
  puts "#{ range.first } - #{ range.last }"
end
