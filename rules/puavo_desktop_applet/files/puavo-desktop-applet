#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import datetime
import getpass
import gettext
import gi
import os
import signal
import subprocess
import sys

gi.require_version('AppIndicator3', '0.1')
gi.require_version('Gtk', '3.0')
gi.require_version('Notify', '0.7')

from gi.repository import AppIndicator3
from gi.repository import GObject
from gi.repository import Gtk
from gi.repository import Notify

gettext.bindtextdomain('puavo-remote-assistance-applet', '/usr/share/locale')
gettext.textdomain('puavo-remote-assistance-applet')
_tr = gettext.gettext


def puavoconf_get(puavoconf_key):
  return subprocess.check_output([ 'puavo-conf', puavoconf_key ]).rstrip() \
                   .decode('utf-8')


class RemoteAssistance:
  def __init__(self, applet):
    self.applet = applet
    self.config = self.parse_config()

    # always disable vino remote access
    self.disable_vino_remote_access()

    try:
      if 'ssh' in self.config['show_accesscontrols_for']:
        time_when_ssh_was_enabled = self.time_when_ssh_was_enabled()

        # disable ssh remote access if it has not been enabled for a while
        self.disable_stale_ssh_remote_access(
          self.config['ssh_access_timeout'],
          time_when_ssh_was_enabled)

    except subprocess.CalledProcessError:
      # /usr/lib/puavo-ltsp-client/admin-remote-connections does not behave
      # properly, so do not handle ssh (indicates misconfiguration)
      print("admin-remote-connections returned failure," \
              + " check your configuration",
            file=sys.stderr)
      config['show_accesscontrols_for'] \
        = filter(lambda x: x != 'ssh', config['show_accesscontrols_for'])

    self.latest_vino_enabled = None
    self.latest_ssh_enabled  = None


  def parse_config(self):
    config = {
      'new_bugreport_browser':   'firefox',
      'new_bugreport_url':       None,
      'show_accesscontrols_for': [ 'vino' ],
      'ssh_access_timeout':      None,
      'vino_network_interface':  None,
    }

    for config_key in config.keys():
      puavoconf_key = ("puavo.support.%s" % config_key)
      try:
        puavoconf_value = puavoconf_get(puavoconf_key)
      except Exception as e:
        print("Could not read puavo-conf variable '%s': %s" \
                %(puavoconf_key, e),
              file=sys.stderr)
        continue

      try:
        if config_key == 'show_accesscontrols_for':
          if puavoconf_value == '':
            puavoconf_value = []
          else:
            puavoconf_value = puavoconf_value.split(',')
        elif config_key == 'ssh_access_timeout':
          if puavoconf_value == '':
            puavoconf_value = None
          else:
            puavoconf_value = int( puavoconf_value.rstrip(os.linesep) )
        elif puavoconf_value == '':
          puavoconf_value = None

        config[config_key] = puavoconf_value

      except Exception as e:
        print("Could not interpret puavo-conf variable '%s': %s" \
                % (puavoconf_key, e),
              file=sys.stderr)

    return config


  def call_puavo_admin_remote_connections(self, cmdargs):
    cmdpath = '/usr/lib/puavo-ltsp-client/admin-remote-connections'
    return subprocess.check_output([ cmdpath ] + cmdargs).decode('utf-8')


  def enable_ssh_remote_access(self):
    self.call_puavo_admin_remote_connections([ '--accept-incoming' ])


  def enable_vino_remote_access(self, network_interface):
    dconf_values = {
      '/org/gnome/desktop/remote-access/enabled':            "true",
      '/org/gnome/desktop/remote-access/icon-visibility':    "'client'",
      '/org/gnome/desktop/remote-access/notify-on-connect':  "true",
      '/org/gnome/desktop/remote-access/prompt-enabled':     "true",
      '/org/gnome/desktop/remote-access/require-encryption': "true",
      '/org/gnome/desktop/remote-access/view-only':          "false",
    }

    # we may want to restrict remote access to a particular network
    # interface
    if network_interface:
      network_interface_dconf_value = ("'%s'" % network_interface)
    else:
      network_interface_dconf_value = "''"

    dconf_values['/org/gnome/desktop/remote-access/network-interface'] \
      = network_interface_dconf_value

    self.set_dconf_values(dconf_values)

    subprocess.Popen([ '/usr/lib/vino/vino-server', '--sm-disable' ],
                     close_fds=True)


  def check_ssh_remote_access(self):
    args = [ '--is-incoming-accepted' ]
    status = self.call_puavo_admin_remote_connections(args)

    return (status.rstrip(os.linesep) == 'yes')


  def check_vino_remote_access(self):
    dconf_key = '/org/gnome/desktop/remote-access/enabled'
    out = subprocess.check_output([ 'dconf', 'read', dconf_key ]) \
                    .decode('utf-8')

    return (out.rstrip(os.linesep) == 'true')


  def disable_ssh_remote_access(self):
    self.call_puavo_admin_remote_connections([ '--reject-incoming' ])


  def disable_vino_remote_access(self):
    dconf_values = {
      '/org/gnome/desktop/remote-access/enabled':            "false",
      '/org/gnome/desktop/remote-access/icon-visibility':    "'client'",
      '/org/gnome/desktop/remote-access/network-interface':  "''",
      '/org/gnome/desktop/remote-access/notify-on-connect':  "true",
      '/org/gnome/desktop/remote-access/prompt-enabled':     "true",
      '/org/gnome/desktop/remote-access/require-encryption': "true",
      '/org/gnome/desktop/remote-access/view-only':          "true",
    }

    self.set_dconf_values(dconf_values)

    user = getpass.getuser()
    subprocess.call([ 'pkill', '-x', '-U', user, 'vino-server' ])


  def disable_stale_ssh_remote_access(self, timeout_seconds, time_when_enabled):
    # not enabled, nothing to do
    if time_when_enabled == None:
      return

    # timeout_seconds can be null/None, in which case we do nothing
    if timeout_seconds == None:
      return

    # zero timeout means that we always disable ssh access.
    if timeout_seconds == 0:
      self.disable_ssh_remote_access()
      return

    timedelta = (datetime.datetime.now() - datetime.datetime.fromtimestamp(0))
    time_in_seconds = int( timedelta.total_seconds() )

    time_since_enabled = time_in_seconds - time_when_enabled

    if time_since_enabled >= timeout_seconds:
      self.disable_ssh_remote_access()


  def time_when_ssh_was_enabled(self):
    args = [ '--show-enable-time' ]
    time_when_enabled_string = self.call_puavo_admin_remote_connections(args)

    if time_when_enabled_string.rstrip(os.linesep) == 'not enabled':
      return None

    return int(time_when_enabled_string)


  def set_dconf_values(self, dconf_values):
    for key, value in dconf_values.items():
      subprocess.check_call([ 'dconf', 'write', key, value ])


  def get_available_access_controls_string(self, wanting_enabled_state):
    available_list = []

    # When wanting_enabled_state is True, we add to available_list
    # when access is enabled.  When wanting_enabled_state is False,
    # we add to available_list when access is disabled.

    if self.ssh_controls_available():
      ssh_enabled = self.check_ssh_remote_access()
      if ssh_enabled == wanting_enabled_state:
        available_list.append('SSH')

    if self.vino_controls_available():
      vino_enabled = self.check_vino_remote_access()
      if vino_enabled == wanting_enabled_state:
        available_list.append('VNC')

    if len(available_list) == 0:
        return None

    return ('(%s)' % ('/'.join(available_list)))


  def check_for_changed_settings(self):
    # XXX We poll because we may lack inotify (nfs, overlayfs)
    # XXX and thus smarter solutions may not work.

    ssh_settings_changed = False
    if self.ssh_controls_available():
      old_latest_ssh_enabled = self.latest_ssh_enabled
      self.latest_ssh_enabled = self.check_ssh_remote_access()
      ssh_settings_changed = (old_latest_ssh_enabled != self.latest_ssh_enabled)

    vino_settings_changed = False
    if self.vino_controls_available():
      old_latest_vino_enabled = self.latest_vino_enabled
      self.latest_vino_enabled = self.check_vino_remote_access()
      vino_settings_changed \
        = (old_latest_vino_enabled != self.latest_vino_enabled)

    return ssh_settings_changed or vino_settings_changed


  def create_access_controls(self):
    to_disable_msg = self.get_available_access_controls_string(True)
    to_enable_msg  = self.get_available_access_controls_string(False)

    if to_disable_msg:
      access_state_msg = '%s %s' % (_tr('Remote access allowed'),
                                    to_disable_msg)
      indicator_icon = 'puavoremoteaccess-green'
    elif to_enable_msg:
      access_state_msg = '%s %s' % (_tr('Remote access denied'), to_enable_msg)
      indicator_icon = 'puavoremoteaccess-grey'
    else:
      # if there is nothing to enable/disable, just show nothing
      return False

    self.access_status_label = Gtk.MenuItem('-=> %s <=' % access_state_msg)
    self.access_status_label.set_sensitive(False)
    self.access_status_label.show()
    self.applet.menu.append(self.access_status_label)

    if to_enable_msg:
      enable_msg = '%s %s' % (_tr('Enable remote access'), to_enable_msg)
      self.enable_access_button = Gtk.MenuItem(enable_msg)
      self.enable_access_button.connect('activate', self.enable_remote_access)
      self.enable_access_button.show()
      self.applet.menu.append(self.enable_access_button)

    if to_disable_msg:
      disable_msg = '%s %s' % (_tr('Disable remote access'), to_disable_msg)
      self.disable_access_button = Gtk.MenuItem(disable_msg)
      self.disable_access_button.connect('activate', self.disable_remote_access)
      self.disable_access_button.show()
      self.applet.menu.append(self.disable_access_button)

    self.applet.indicator.set_icon(indicator_icon)


  def disable_remote_access(self, widget):
    if self.ssh_controls_available():
      self.disable_ssh_remote_access()

    if self.vino_controls_available():
      self.disable_vino_remote_access()

    self.applet.create_menu()


  def enable_remote_access(self, widget):
    if self.ssh_controls_available():
      self.enable_ssh_remote_access()

    if self.vino_controls_available():
      interface = self.config['vino_network_interface']
      self.enable_vino_remote_access(interface)

    self.applet.create_menu()


  def make_bugreport(self, widget):
    browser = self.config['new_bugreport_browser']
    url     = self.config['new_bugreport_url']

    if browser == 'firefox':
      cmd = [ browser, '-new-window', url ]
    else:
      cmd = [ browser, url ]

    subprocess.Popen(cmd, close_fds=True)


  def ssh_controls_available(self):
    return ('ssh' in self.config['show_accesscontrols_for'])


  def vino_controls_available(self):
    # vino-server can not be started in login screen
    if getpass.getuser() == 'Debian-gdm':
      return False

    return ('vino' in self.config['show_accesscontrols_for'])


  def append_items_to_menu(self):
    self.create_access_controls()

    make_bugreport_button = self.config['new_bugreport_browser'] \
                              and self.config['new_bugreport_url'] \
                              and getpass.getuser() != 'Debian-gdm'
    if make_bugreport_button:
      self.new_ticket_button = Gtk.MenuItem( _tr('New support request') )
      self.new_ticket_button.connect('activate', self.make_bugreport)
      self.new_ticket_button.show()
      self.applet.menu.append(self.new_ticket_button)




class PuavoDesktopApplet:
    def __init__(self):
        # XXX this should be something else and maybe puavo-conf configurable?

        self.indicator = AppIndicator3.Indicator.new('puavo-desktop-applet',
                            'puavoremoteaccess-grey',
                            AppIndicator3.IndicatorCategory.SYSTEM_SERVICES)
        self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)

        self.remote_assistance = RemoteAssistance(self)

        self.menu = False
        self.create_menu()


    def create_menu(self):
        if self.menu:
            self.menu.destroy()

        self.menu = Gtk.Menu()

        self.remote_assistance.append_items_to_menu()
        self.menu.show_all()

        self.indicator.set_menu(self.menu)


    def check_for_changed_settings(self):
        if self.remote_assistance.check_for_changed_settings():
          self.create_menu()


    def main(self):
        self.check_for_changed_settings()
        GObject.timeout_add_seconds(5, self.check_for_changed_settings)

        Gtk.main()


applet = PuavoDesktopApplet()

if __name__ == '__main__':
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    applet.main()
