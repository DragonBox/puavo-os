#!/usr/bin/ruby
# -*- coding: utf-8 -*-

require 'etc'
require 'find'
require 'open3'
require 'puavo/sharedir/ldap'
require 'puavo/sharedir/shared_directories'
require 'rb-inotify'
require 'socket'
require 'syslog'
require 'yaml'

ShareDirBase = '/home/share'

class PuavoShare
  attr_reader :automatic_acls

  # XXX this many parameters to a function suggests that
  # XXX maybe there is a need for another class... DirSpec ?
  def initialize(basedir_description,
		 basedir_path,
		 sharepath,
		 writegroups,
		 readgroups,
		 name,
		 automatic_acls)

    @basedir_description = basedir_description
    @basedir_path        = basedir_path
    @sharepath           = sharepath
    @writegroups         = writegroups
    @readgroups          = readgroups
    @name                = name
    @automatic_acls      = automatic_acls

    @wanted_directory_acls = make_wanted_acls('rwx', 'r-x', true)
    @wanted_file_acls      = make_wanted_acls('rw-', 'r--', false)
  end

  def bookmark_definition
    {
      'basedir_description' => @basedir_description,
      'basedir_path'        => @basedir_path,
      'description'         => @name,
      'path'                => @sharepath,
      'readgroups'          => @readgroups,
      'writegroups'         => @writegroups,
    }
  end

  def create_sharedir
    self.class.mkdir(@sharepath, 0)
  end

  def fix_acls(path)
    return unless @automatic_acls

    begin
      actual_acls = getfacl(path)
    rescue SignalException
      raise
    rescue Exception => e
      Syslog.warning('%s', e.message)
      return
    end

    wanted_acls = get_wanted_acls(path)

    # getfacl() returns empty in case of symbolic links, only change their
    # ownerships (permissions on symbolic links do not matter).
    if actual_acls.empty?
      begin
        if File.symlink?(path)
	  lstat = File.lstat(path)
	  if lstat.uid != 0 or lstat.gid != 0
	    File.lchown(0, 0, path)
	  end
        end
      rescue
      end
      return
    end

    # Only change things if change is needed.
    return if wanted_acls == actual_acls

    reset_acls(path, wanted_acls)
  end

  def fix_acls_recursively(path=nil)
    return unless @automatic_acls

    Find.find(path || @sharepath) { |path| fix_acls(path) }
  end

  def getfacl(path)
    acls = ''
    cmd = [ 'getfacl', '-P', '-p', '-n', '--', path ]
    Open3.popen3(*cmd) do |stdin, stdout, stderr|
      acls = stdout.readlines.select { |l| not l =~ /^# file:/ }.join('')
      errormsg = stderr.read
      if not errormsg.empty?
	raise "Could not get ACLs for #{ path }: #{ errormsg }"
      end
    end
    normalize_acl(acls)
  end

  def get_wanted_acls(filename)
    if File.directory?(filename)
      @wanted_directory_acls
    else
      @wanted_file_acls
    end
  end

  def make_wanted_acls(rwmode, romode, add_defaults)
    return unless @automatic_acls

    wgids = @writegroups.map { |g| Etc.getgrnam(g).gid }
    rgids = @readgroups .map { |g| Etc.getgrnam(g).gid }

    acl_array = [
      "# owner: 0",
      "# group: 0",
      "user::#{ rwmode }",
      'group::---',
      wgids.map { |group| "group:#{ group }:#{ rwmode }" },
      rgids.map { |group| "group:#{ group }:#{ romode }" },
      "mask::#{ rwmode }",
      'other::---',

      add_defaults ? [
        'default:user::rwx',
        'default:group::---',
        wgids.map { |group| "default:group:#{ group }:#{ rwmode }" },
        rgids.map { |group| "default:group:#{ group }:#{ romode }" },
	"default:mask::#{ rwmode }",
	'default:other::---',
      ] : nil,
    ].compact.flatten

   normalize_acl(acl_array.map { |l| "#{ l }\n" }.join(''))
  end

  def self.mkdir(path, mode)
    begin
      Dir.mkdir(path, mode)
      Syslog.notice('%s', "Created directory #{ path }.")
    rescue Errno::EEXIST
    end
  end

  def normalize_acl(acls)
    acls.split("\n").sort.join("\n")
  end

  def parent_of?(path)
    path.to_s[0, @sharepath.length] == @sharepath
  end

  def reset_acls(filename, wanted_acls)
    raise 'This should never be called unless @automatic_acls is set' \
      unless @automatic_acls

    if parent_of?(filename)
      begin
	uid = File.stat(filename).uid
	Syslog.info('%s', "Reset ACLs for #{ filename } (uid=#{ uid }).")

        # First set ACLs and then change owner to root.  This is to allow
        # "cp -R $src $target" and similar to work, so that at every moment
        # a user has a write permission to directories.
	setfacl(filename, wanted_acls)
	File.chown(0, 0, filename)

      rescue Errno::ENOENT
      rescue SignalException
        raise
      rescue Exception => e
	msg = "Error in resetting permissions for #{ filename }: " \
	      + "#{ e.message }: #{ e.backtrace.inspect }."
        Syslog.err('%s', msg)
      end
    else
      msg = "Internal error: called reset_acls() with path " \
	    + "#{ filename } that is not under #{ @sharepath }."
      Syslog.warning('%s', msg)
    end
  end

  def setfacl(path, wanted_acls)
    # "-P" is good and works (despite the manual page that says otherwise).
    # We want this to avoid changing the permissions of files symbolic links
    # may point to.
    cmd = [ 'setfacl', '-P', '--set-file=-', '--', path ]
    Open3.popen3(*cmd) do |stdin, stdout, stderr|
      stdin.write(wanted_acls)
      stdin.close
      errormsg = stderr.read
      if not errormsg.empty?
	raise "Could not set ACLs for #{ path }: #{ errormsg }"
      end
    end
  end
end

class ShareBox
  def initialize(admins)
    @admin_groupnames = admins.map { |group| Array(group['cn']).first }
    @shares = {}
  end

  def add_dir(basedir_description,
	      basedir_path,
	      path,
	      description,
	      writegroups,
	      readgroups,
	      automatic_acls)
    # check directory mode to allow disabling directories (chmod 000)
    begin
      return if (File.stat(path).mode & 0x777) == 0
    rescue Errno::ENOENT
      # if directory does not exist, it is enabled (it should be created)
    end

    share = PuavoShare.new(basedir_description,
			   basedir_path,
			   path,
			   @admin_groupnames | writegroups.keys,
			   readgroups.keys,
			   description,
			   automatic_acls)

    share.create_sharedir
    @shares[path] = share
  end

  def fix_acls(path)
    @shares.values.each do |share|
      if share.parent_of?(path)
        # in case of a directory, it might have been moved from another
	# directory, in which case we need to traverse it
        if File.directory?(path)
          share.fix_acls_recursively(path)
        else
          share.fix_acls(path)
        end
      end
    end
  end

  def fix_acls_recursively
    Syslog.notice('%s', 'Fixing permissions recursively.')
    @shares.values.each do |share|
      share.fix_acls_recursively
    end
  end

  def paths_with_automatic_acls
    @shares.map { |path, share| share.automatic_acls ? path : nil }.compact
  end
end

class PuavoShareLDAP
  def initialize
    @puavoldap = PuavoLdap.new
  end

  def find_groups(filter)
    groups = []
    @puavoldap.search_with_baseprefix('ou=Groups', filter) do |entry|
      groups << entry.to_hash
    end
    groups
  end

  def find_groups_by_school(schoolname)
    schoolfilter = "(&(objectClass=puavoSchool)(cn=#{ schoolname }))"
    schooldn     = ''
    @puavoldap.search_with_baseprefix('ou=Groups', schoolfilter) do |entry|
      schooldn = entry.dn
    end

    find_groups("(&(objectClass=puavoEduGroup)(puavoSchool=#{ schooldn }))")
  end

  def find_locale(schoolgroup)
    school_language = Array(schoolgroup['preferredLanguage']).first
    if school_language
      return school_language
    else
      @puavoldap.search('(objectClass=puavoEduOrg)') do |entry|
        return Array(entry['preferredLanguage']).first
      end
    end

    raise "No language can be found for '#{ Array(schoolgroup['cn']).first }'"
  end

  def find_school_groups()
    find_groups('(objectClass=puavoSchool)')
  end

  def find_teacher_groups()
    groups = find_groups('(objectClass=puavoEduGroup)')
    # XXX we need something smarter here than regexp
    groups.select { |group| Array(group['cn']).first =~ /(-ope|opettajat)/ }
  end

  def unbind
    @puavoldap.unbind
  end
end

class Control
  def initialize_shares_from_ldap
    shareldap = PuavoShareLDAP.new

    admins   = shareldap.find_teacher_groups()
    @schools = shareldap.find_school_groups()

    @box = ShareBox.new(admins)

    make_sharebase()
    @schools.each do |schoolgroup|
      add_directory(shareldap, schoolgroup)
    end

    shareldap.unbind
  end

  def add_directory(shareldap, schoolgroup)
    school_name        = Array(schoolgroup['cn']).first
    school_displayname = Array(schoolgroup['displayName']).first

    school_sharedir = "#{ ShareDirBase }/#{ school_name }"

    PuavoShare.mkdir(school_sharedir, 0755)

    Syslog.notice('%s',
		  "Directory #{ school_sharedir } is added to managed directories.")

    school_groups = shareldap.find_groups_by_school(school_name)
    lang          = shareldap.find_locale(schoolgroup)

    basedir_path \
      = PuavoSharedDirectories.dirpath(school_sharedir, 'base', lang)
    basedir_description \
      = PuavoSharedDirectories.description('base', lang, school_displayname)

    PuavoShare.mkdir(basedir_path, 0755)

    @box.add_dir(
      basedir_description,
      basedir_path,
      PuavoSharedDirectories.dirpath(school_sharedir, 'programs', lang),
      PuavoSharedDirectories.description('programs', lang, school_displayname),
      { school_name => school_displayname },
      {},
      false)

    @box.add_dir(
      basedir_description,
      basedir_path,
      PuavoSharedDirectories.dirpath(school_sharedir, 'material', lang),
      PuavoSharedDirectories.description('material', lang, school_displayname),
      {},
      { school_name => school_displayname },
      true)

    @box.add_dir(
      basedir_description,
      basedir_path,
      PuavoSharedDirectories.dirpath(school_sharedir, 'all', lang),
      PuavoSharedDirectories.description('all', lang, school_displayname),
      { school_name => school_displayname },
      {},
      true)

    school_groups.each do |group|
      group_name        = Array(group['cn']).first
      group_displayname = Array(group['displayName']).first

      @box.add_dir(
	basedir_description,
	basedir_path,
	PuavoSharedDirectories.dirpath(school_sharedir,
				       'group',
				       lang,
				       group_name),
        PuavoSharedDirectories.description('group',
				           lang,
					   school_displayname,
					   group_name),
        { group_name => group_displayname },
        {},
        true)
    end
  end

  def fix_acls_recursively
    @box.fix_acls_recursively
  end

  def make_sharebase
    # make share directory and symlinks for all supported languages for it
    PuavoShare.mkdir(ShareDirBase, 0755)
    %w(fi sv).each do |lang|
      lang_dirname = PuavoSharedDirectories.dirpath(File.dirname(ShareDirBase),
						    'base',
						    lang)
      begin
        File.symlink(File.basename(ShareDirBase), lang_dirname)
      rescue Errno::EEXIST
      end
    end
  end

  def run_notifier(max_seconds)
    max_time     = Time.new.to_i + max_seconds
    seconds_left = max_seconds

    begin
      notifier = INotify::Notifier.new
      begin
	@box.paths_with_automatic_acls.each do |monitor_path|
	  events = [
	    :create,
	    :dont_follow,
	    :modify,
	    :moved_to,
	    :move_self,
	    :recursive,
	  ]

	  Syslog.debug('%s', "Setting notifier watch on #{ monitor_path }.")
	  notifier.watch(monitor_path, *events) do |event|
	    path = event.absolute_name

	    # :recursive does not work reliably due to some race condition,
	    # so we must help it a bit for freshly created directories
	    if File.directory?(path)
	      notifier.watch(path, *events)
	    end

	    Syslog.info('%s', "An event occurred on #{ path }, checking ACLs.")
	    @box.fix_acls(path)
	  end
	end

	while IO.select([ notifier.to_io ], [], [], seconds_left)
	  notifier.process
	  seconds_left = [ max_time - Time.new.to_i, 0 ].max
	  break if seconds_left == 0
	end
      ensure
	# XXX notifier.close did not work in version 0.7.0-3,
	# XXX hopefully this does the same
	notifier.to_io.close
      end
    rescue SignalException
      raise
    rescue Exception => e
      msg = "Error with inotifier: #{ e.message }: #{ e.backtrace.inspect }." \
	    + '  Check out the limit in /proc/sys/fs/inotify/max_user_watches.'
      Syslog.err('%s', msg)
    end
  end

  def run_notifier_but_breakout_at_nighttime
    # Run run_notifier for (25 - Time.new.hour) hours, so we will break out
    # to searching LDAP and fixing all file permissions once a night,
    # somewhere between one and two o'clock.
    Syslog.debug('%s', 'Starting notifier.')
    run_notifier((25 - Time.new.hour) * 60 * 60)
    Syslog.debug('%s', 'Broke out of notifier.')
  end
end

loop do
  Syslog.open(File.basename($0), Syslog::LOG_DAEMON \
				 | Syslog::LOG_CONS \
				 | Syslog::LOG_PERROR \
				 | Syslog::LOG_PID)

  exception_msg = nil
  begin
    control = Control.new
    control.initialize_shares_from_ldap

    notifier_pid = fork { control.run_notifier_but_breakout_at_nighttime }
    control.fix_acls_recursively
    Process.waitpid(notifier_pid)

  rescue LDAP::ResultError => e
    exception_msg = \
      "Error in accessing LDAP: #{ e.message }: #{ e.backtrace.inspect }."
  rescue SignalException
    Syslog.notice('%s', 'Received SignalException, terminating.')
    exit 0
  rescue Exception => e
    exception_msg = \
      "Unknown error: #{ e.message }: #{ e.backtrace.inspect }."
  end

  if exception_msg
    Syslog.err('%s', exception_msg)
    sleep 60	# wait a while in case errors just repeat and repeat...
  end

  Syslog.close
end

# tests:
#
# rm -rf 1; \
# for i in $(seq 100); do \
#   FOO=""; \
#   for j in $(seq $i); do \
#     FOO="$FOO$j/"; \
#   done; \
#   DATA=$(getfacl $(dirname $FOO)); \
#   mkdir -p $FOO || { echo -e -n "$DATA\n\n"; getfacl $(dirname $FOO); \
#   break; }; \
# done
